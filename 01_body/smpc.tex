\chapter{Ασφαλής Υπολογισμός Πολλών Μερών}
\label{chapter:SMPC}

Στην ενότητα αυτή θα γίνει μια εισαγωγή στον Ασφαλή Υπολογισμό Πολλών Μερών (Secure Multi Party Computation ή (SMPC)) και στη συνέχεια θα περιγραφούν και θα αναλυθούν ορισμένα βασικά πρωτόκολλα που χρησιμοποιούνται μέχρι και σήμερα. Σχετικά με την ανάλυση των πρωτοκόλλων, θα ξεκινήσουμε από τα πιο απλά και ιστορικά που είναι ασφαλή ενάντια σε παθητικούς αντιπάλους και θα συνεχίσουμε προς τα πιο σύνθετα και σύγχρονα που είναι ασφαλή ενάντια σε ενεργητικούς αντιπάλους. Δυστυχώς, παρότι σε κάποια πρωτόκολλα ίσως είναι προφανής η ιδιότητα της ασφάλεια τους για συγκεκριμένα μοντέλα αντιπάλων, η πλήρης τυποποιημένη απόδειξη της ασφάλειας αυτής για όλα τα πρωτόκολλα που θα αναλύσουμε θα χρειαζόταν τουλάχιστον κάποιες δεκάδες σελίδες σελίδες παραπάνω και θα ξέφευγε από τα πλαίσια της εργασίας αυτής. Ωστόσο, η μεθοδολογία που περιγράψαμε στο Κεφάλαιο \ref{chapter:security} καθώς και η παρατιθέμενη βιβλιογραφία δίνει ένα καλό εναρκτήριο σημείο για τον αναγνώστη που θέλει να εντρυφήσει στις αποδείξεις αυτές. Τα πρωτόκολλα που θα περιγράψουμε στο κεφάλαιο αυτό είναι τα Μπερδεμένα Κυκλώματα Yao, το BMR, το GMW και το SPDZ. Τα πρώτα τρία πρωτόκολλα υποστηρίζονται από τη βιβλιοθήκη ABY που χρησιμοποιούμε στο υλοποιητικό κομμάτι αυτής της εργασίας που βρίσκεται στο Κεφάλαιο \ref{chapter:implementation}. Είναι και τα τρία ασφαλή ενάντια σε παθητικούς αντιπάλους. Το τελευταίο πρωτόκολλο είναι ένα από τα πιο σύγχρονα και επιτυχημένα πρωτόκολλα που έχουν προταθεί στη βιβλιογραφία και παρότι δε σχετίζεται με την υλοποίηση επιλέξαμε να το αναλύσουμε για να υπάρχει σφαιρικότερη κάλυψη της βιβλιογραφίας, αφού είναι ασφαλές ενάντια σε ενεργητικούς αντιπάλους.

Στο Κεφάλαιο \ref{chapter:intro} κάναμε μια πολύ μικρή εισαγωγή στον κλάδο SMPC. Τα SMPC είναι διαδραστικά πρωτόκολλα στα οποία συμμετέχουν δύο ή περισσότεροι συμμετέχοντες, οι οποίοι διαθέτουν καμία, μία ή περισσότερες ιδιωτικές εισόδους. Η συνάρτηση που πρέπει να αποτιμηθεί για τις εισόδους αυτές, πρέπει να είναι από πριν γνωστή στους συμμετέχοντες, ώστε σε πρωτόκολλα που το υποστηρίζουν να μπορούν να επαληθεύσουν αν αυτή που πρόκειται να αποτιμηθεί είναι η προσυμφωνηθήσα συνάρτηση. Σχετικά με την ασφάλεια του Υπολογισμού Πολλών Μερών είναι σημαντικό να αναφέρουμε ότι τα πρωτόκολλα SMPC μεριμνούν αποκλειστικά και μόνο για την ασφαλή αποτίμηση του υπολογισμού. Αυτό σημαίνει ότι το αποτέλεσμα της αποτίμησης του υπολογισμού μπορεί να αποκαλύπτει σημαντικές πληροφορίες για την είσοδο κάποιου άλλου συμμετέχον, όπως για παράδειγμα στην περίπτωση μιας πύλης AND με δύο εισόδους όπου ελέγχονται από δύο συμμετέχοντες αντίστοιχα. Ας αναλογιστούμε το παράδειγμα της Ασφάλειας μέσω Προσομοίωσης, η οποία χρησιμοποιείται κατά κόρον στον κλάδο του SMPC. Στην περίπτωση αυτή, ένα πρωτόκολλο SMPC που έχει αποδειχθεί ασφαλές με αυτήν τη μέθοδο μας διασφαλίζει ότι οποιοσδήποτε αντίπαλος που ελέγχει κάποιους διεφθαρμένους συμμετέχοντες που συμμετέχουν στο πρωτόκολλο για την αποτίμηση του υπολογισμού δε μαθαίνει καμία πληροφορία παραπάνω από τη διαδικασία εκτέλεσης του πρωτοκόλλου, σε σχέση με την πληροφορία που θα μάθαινε αν συμμετείχε σε ένα πρωτόκολλο ιδανικού κόσμου. Προφανώς, ο αριθμός των διεφθαρμένων συμμετεχόντων που ελέγχονται από τον αντίπαλο, η υπολογιστική ισχύς του αντιπάλου καθώς και ο τρόπος διαφθοράς των συμμετεχόντων εξαρτάται από το μοντέλο αντιπάλου που έχουμε επιλέξει. Είναι αντιληπτό ότι τη γνώση που θα αποκτούσε ένας αντίπαλος στην περίπτωση μιας πύλης AND θα την αποκτούσε σε οποιοδήποτε, ιδανικό ή μη, πρωτόκολλο αποτίμησης της.

Στην ενότητα αυτή βασικές βιβλιογραφικές πηγές αποτέλεσαν τα βιβλία \cite{10.1561/3300000019} και \cite{cramer2015secure}. Επίσης, χρήσιμες εργασίες εισαγωγής και σύνοψης του κλάδου, αποτελούν οι \cite{cryptoeprint:2020/300} και  \cite{zhao2019secure}. Στην συνέχεια θα αναλύσουμε τα βασικά χαρακτηριστικά με βάση τα οποία μπορούμε να κατηγοριοποιήσουμε τα πρωτόκολλα SMPC.

\section{Κατηγορίες πρωτοκόλλων ως προς το μοντέλο αναπαράσταση του υπολογισμού}

Οποιοδήποτε πρωτόκολλο SMPC, για να εκτελέσει τον υπολογισμό μιας συνάρτησης $f$, χρειάζεται να λάβει την συνάρτηση σε μια συγκεκριμένη μορφή που εξαρτάται από το τύπο του πρωτοκόλλου. Δηλαδή, αν θέλουμε να χρησιμοποιήσουμε το πρωτόκολλο αυτό καλούμαστε να αναπαραστήσουμε την $f$ στο κατάλληλο υπολογιστικό μοντέλο για το οποίο έχει φτιαχτεί το πρωτόκολλο. Αυτό συμβαίνει, με οποιαδήποτε μηχανή υπολογισμού, σε έναν Επεξεργαστή (CPU) ή σε μια Εικονική Μηχανή για παράδειγμα χρειάζεται να αναπαραστήσουμε την $f$ στην κατάλληλη συμβολική γλώσσα ενώ σε μια Μηχανή Turing χρειάζεται να την αναπαραστήσουμε με την κατάλληλη αλγεβρική δομή. Στην περίπτωση των πρωτοκόλλων SMPC οι κύριες κατηγορίες που τα διακρίνουμε ως προς την αναπαράσταση της $f$ είναι οι παρακάτω :

\begin{definition}
\textbf{Κύρια Υπολογιστικά Μοντέλα των SMPC πρωτοκόλλων :}
\begin{itemize}
    \item Αναπαράσταση ως Boolean δίκτυο/κύκλωμα Συνδυαστικής Λογικής
    \item Αναπαράσταση ως Αριθμητικό δίκτυο/κύκλωμα, ένα παράδειγμα τέτοιου δικτύου δίνεται στο Σχήμα  \ref{fig:arithmetic-circuit}
    \item Πιο σύνθετες αναπαραστάσεις, όπως ως Μηχανή Turing ή RAM (Random Access Machine)
\end{itemize}
\end{definition}

\begin{figure}
    \usetikzlibrary {graphs}
    \tikz
    \graph [nodes={draw, circle}] {
            {x, y} -> {+} -> {*} -> w,
        y -> {*}
    };
    \caption{Παράδειγμα αριθμητικού δικτύου}
    \label{fig:arithmetic-circuit}
\end{figure}

Στα πλαίσια αυτής της εργασίας θα αναφερθούμε μόνο σε πρωτόκολλα που ανήκουν στις πρώτες δύο κατηγορίες. Τα πρωτόκολλα που ανήκουν στην τελευταία κατηγορία αποτελούν ιδιαίτερα ενεργό ερευνητικό κλάδο την τελευταία δεκαετία με αρκετά σημαντικές εργασίες όπως οι \cite{cryptoeprint:2014/082} και \cite{goldwasser2013run}.

Προφανώς, οι παραπάνω κατηγορίες Boolean και Αριθμητικών δίκτυο σχετίζονται μεταξύ τους καθώς μπορούμε εύκολα να χρησιμοποιήσουμε ένα Αριθμητικό δίκτυο για τον υπολογισμό ενός Boolean κυκλώματος. Αν πάρουμε για παράδειγμα μια πύλη AND μπορούμε να τη μετατρέψουμε σε αριθμητική ως εξής :
%
\[
\begin{aligned}
    NAND(x, y)  &= AND(OR(x,y), OR(x,NOT(y)), OR(NOT(x),y)) =\\
                &= OR(x,y) + OR(x,NOT(y)) + OR(NOT(x),y) =\\
                &= x \cdot y + x \cdot NOT(y) + NOT(x) \cdot y =\\
                &= x \cdot y + x \cdot (1-y) + (1-x) \cdot y
\end{aligned}
\]
%
Στην συγκεκριμένη μαθηματική έκφραση κάνουμε διαχωρισμό μεταξύ των λογικών πυλών τις οποίες σημειώνουμε με τα ονόματα τους και των συμβόλων τις πρόσθεσης, της αφαίρεσης και του πολλαπλασιασμού οι οποίες αναφέρονται στο μαθηματικό δακτύλιο ή πεδίο στο οποίο ανήκουν τα στοιχεία $x,y$. Μπορούμε επίσης να χρησιμοποιήσουμε και ένα Boolean κύκλωμα για τον υπολογισμό ενός αριθμητικού δικτύου, χρησιμοποιώντας χρησιμοποιώντας, για παράδειγμα, έναν την αναπαράσταση ενός Αθροιστή (Adder) ή ενός Πολλαπλασιαστή (Multiplier) σε Boolean πύλες. Με παρόμοιο τρόπο λειτουργεί και η βιβλιοθήκη MPC-BLAS που υλοποιήσαμε και στην οποία θα αναφερθούμε στο Κεφάλαιο \ref{chapter:implementation}. Συνήθως βέβαια πρέπει να τονίσουμε πως οι μετατροπές από το έναν τρόπο υπολογισμού στον άλλο δεν είναι ιδιαίτερα αποδοτικές. Δηλαδή η χρήση ενός Boolean κυκλώματος για την εκτέλεση μιας πράξης πολλαπλασιασμού δεν ενδύκνειται, ωστόσο δεν έχουμε πάντα την επιλογή.

Σε αυτό το σημείο πρέπει να αναφερθεί πως ορισμένα πρωτόκολλα SMPC υποστηρίζουν μόνο πεπερασμένο υπολογισμό, δηλαδή πεπερασμένους σε χρόνο αλγορίθμους, και άρα δεν μπορεί να περιέχει άπειρους βρόγχους. Δηλαδή, απαιτείται να γίνει Ξετύλιγμα των βρόγχων (Loop unrolling) στην περίπτωση που υπάρχουν. Αυτό συνήθως συμβαίνει σε πρωτόκολλα στα οποία το κύκλωμα πρέπει να αρχικοποιηθεί (bootstrap) ολόκληρο πριν ξεκινήσει ο υπολογισμός. Στα πρωτόκολλα που θα εξετάσουμε δε συμβαίνει αυτό στην περίπτωση της ασφάλειας ενάντια σε παθητικούς αντιπάλους. Ωστόσο, είμαστε αντιμέτωποι με το εμπόδιο αυτό αν επιθυμήσουμε να μετατρέψουμε τα πρωτόκολλα αυτά σε ασφαλή ενάντια σε ενεργητικούς αντιπάλους μέσω κάποιων ειδικών τεχνικών που θα εξετάσουμε στη συνέχεια του κεφαλαίου.

\section{Κατηγορίες πρωτοκόλλων ως προς τις ιδιότητες ασφάλειας}

Όπως προαναφέραμε, το μοντέλο αναπαράστασης του υπολογισμού που χρησιμοποιεί ένα πρωτόκολλο είναι σύμφυτο με αυτό. Ένα ακόμα σύμφυτο χαρακτηριστικό ενός πρωτοκόλλου είναι η ασφάλεια του. Γενικότερα στα πρωτόκολλα SMPC διακρίνουμε τις παρακάτω κατηγορίες ασφάλειας πρωτοκόλλων :

\begin{itemize}
    \item Πρωτόκολλα ασφαλή ενάντια σε Παθητικούς Αντιπάλους
        \begin{itemize}
            \item Ασφαλή ενάντια σε διεφθαρμένη μειοψηφία
            \item Ασφαλή ενάντια σε διεφθαρμένη πλειοψηφία
        \end{itemize}
    \item Πρωτόκολλα ασφαλή ενάντια σε Ενεργητικούς Αντιπάλους
        \begin{itemize}
            \item Ασφαλή ενάντια σε διεφθαρμένη μειοψηφία
            \item Ασφαλή ενάντια σε διεφθαρμένη πλειοψηφία
        \end{itemize}
\end{itemize}

Προφανώς ένα πρωτόκολλο που είναι ασφαλές ενάντια σε ενεργητικούς αντιπάλους είναι ασφαλές και ενάντια σε παθητικούς. Το ίδιο ισχύει και στην περίπτωση της μειοψηφίας και πλειοψηφίας των διεφθαρμένων συμμετεχόντων. Στο Σχήμα \ref{fig:mp-sdpz-protocols} παραθέτουμε ,ενδεικτικά, των πίνακα υποστηριζόμενων πρωτοκόλλων και των μοντέλων ασφάλειας στα οποία είναι ασφαλή, της βιβλιοθήκης MP-SPDZ \cite{mp-spdz}. Η βιβλιοθήκη αυτή έχει ίσως την εκτενέστερη υποστήριξη πρωτοκόλλων στην βιβλιογραφία.

\begin{table}[h!]
    \centering
    \resizebox{\columnwidth}{!}{
        \begin{tabular}{|c|l|ll|ll|}
            \hline
            \multicolumn{1}{|l|}{}       &                                                                      & \multicolumn{2}{c|}{Αριθμητικό δίκτυο}                                    & \multicolumn{2}{c|}{Boolean κύκλωμα}                                 \\ \hline
            \multicolumn{1}{|l|}{}       & \diagbox{Μοντέλο Ασφάλειας}{Υπολογιστικό Μοντέλο} & \multicolumn{1}{l|}{$modp$ ή $GF(2^n)$}          & $mod2^n$               & \multicolumn{1}{l|}{Δυαδική Διαμοίραση Μυστικών} & Μπερδεμένα Δίκτυα \\ \hline
            \multirow{}{}{Ενεργητικός}   & Διεφθαρμένη Πλειοψηφία                                               & \multicolumn{1}{l|}{MASCOT / LowGear / HighGear} & SPDZ2k                 & \multicolumn{1}{l|}{Tiny / Tinier}               & BMR               \\ \cline{2-6}
            & Εμπιστή Πλειοψηφία                                                   & \multicolumn{1}{l|}{Shamir / Rep3 / PS / SY}     & Brain / Rep3 / PS / SY & \multicolumn{1}{l|}{Rep3 / CCD / PS}             & BMR               \\ \cline{2-6}
            & Έμπιστη Υπερ-πλειοψηφία                                              & \multicolumn{1}{l|}{Rep4}                        & Rep4                   & \multicolumn{1}{l|}{Rep4}                        & N/A               \\ \hline
            Συγκαλλημένος                       & Διεφθαρμένη Πλειοψηφία                                               & \multicolumn{1}{l|}{CowGear / ChaiGear}          & N/A                    & \multicolumn{1}{l|}{N/A}                         & N/A               \\ \hline
            \multirow{}{}{Παθητικός} & Διεφθαρμένη Πλειοψηφία                                               & \multicolumn{1}{l|}{Semi / Hemi / Temi / Soho}   & Semi2k                 & \multicolumn{1}{l|}{SemiBin}                     & Yao's GC / BMR    \\ \cline{2-6}
            & Έμπιστη Πλειοψηφία                                                   & \multicolumn{1}{l|}{Shamir / ATLAS / Rep3}       & Rep3                   & \multicolumn{1}{l|}{Rep3 / CCD}                  & BMR               \\ \cline{2-6}
            & Dealer                                                               & \multicolumn{1}{l|}{Dealer}                      & Dealer                 & \multicolumn{1}{l|}{Dealer}                      & N/A               \\ \hline
        \end{tabular}
    }
    \caption{Πίνακας υποστηριζόμενων πρωτοκόλλων της βιβλιοθήκης MP-SPDZ \cite{mp-spdz}. Ο παρόν είναι εμπνευσμένος από έναν παρόμοιο, αλλά δυσανάγνωστο, πίνακα που υπάρχει στα εγχειρίδια χρήσης της.}
    \label{fig:mp-sdpz-protocols}
\end{table}

\section{Ασφαλής Υπολογισμός Πολλών Μερών ενάντια σε Παθητικούς Αντιπάλους}

Στη ενότητα αυτή θα εξετάσουμε τρία πρωτόκολλα ιστορικής σημασίας τα οποία χρησιμοποιούνται μέχρι και σήμερα λόγω της ευκολίας υλοποίησης τους και της απόδοσης τους. Τα πρωτόκολλα αυτά είναι τα Μπερδεμένα Δίκτυα Yao, το BMR και το GMW.

\subsection{Πρωτόκολλο Μπερδεμένων Δικτύων Yao (Yao's Garbled Circuits Protocol)}
\label{section:yaos-gc}

Το πρωτόκολλο αυτό όπως αναφέραμε και στην Ενότητα \ref{chapter:intro} προτάθηκε από τον Yao το 1986 στις εργασίες \cite{4568207} \cite{4568388}. Πιο συγκεκριμένα, προτάθηκε ως πρωτόκολλο επίλυσης του Προβλήματος των Εκατομμυριούχων, δηλαδή για την περίπτωση των δύο συμμετεχόντων (2PC). Το συγκεκριμένο πρωτόκολλο απαιτεί την μετατροπή του αλγορίθμου σε μια Boolean συνάρτηση ή αντίστοιχα σε ένα Boolean κύκλωμα Συνδυαστικής Λογικής. Παρακάτω, θα αναλύσουμε την περίπτωση των δύο συμμετεχόντων για μια αυθαίρετη Boolean συνάρτηση και μετά θα αναφερθούμε στο πως μπορεί να επιταχυνθεί ο υπολογισμός με τη χρήση Boolean κυκλώματος. Το πρωτόκολλο αυτό μπορεί να αποδειχθεί ότι είναι ασφαλές απέναντι σε Παθητικούς Αντιπάλους.

\subsubsection{Υπολογισμός με χρήση του Πίνακα Αναζήτησης της συνάρτησης $f$}

Έστω δύο συμμετέχοντες $P_1$ και $P_2$ που θέλουν να εκτελέσουν μια Boolean συνάρτηση $\mathbf{out} = f(\mathbf{x}, \mathbf{y})$ με $x$ και $y$ τα διανύσματα των εισόδων των $P_1$ και $P_2$ αντίστοιχα. Έστω επίσης $x_i^j$, το $i$-οστο bit του διανύσματος $x$ για την τιμή $j$ του bit αυτού.  Γνωρίζουμε πως μια Boolean συνάρτηση μπορεί να περιγραφεί πλήρως από τον Πίνακα Αναζήτησης της (Look-up table). Το πρωτόκολλο αυτό απαιτεί κάποιον συμμετέχον να κάνει την προετοιμασία (bootstraping) ο οποίος πρέπει να γνωρίζει τον πλήρη Πίνακα Αναζήτησης της συνάρτησης $f$. Ας υποθέσουμε ότι ο $P_1$ εκτελεί αυτή τη διαδικασία. Για μια από τις $2 \cdot (\abs{\mathbf{x}} + \abs{\mathbf{y}})$ γραμμές του πίνακα ο $P_1$ κρυπτογραφεί την αντίστοιχη έξοδο της συνάρτησης με $ \abs{\mathbf{x}} + \abs{\mathbf{y}}$ διαφορετικά και ομοιόμορφα τυχαία επιλεγμένα κλειδιά χρησιμοποιώντας ένα συμμετρικό κρυπτογραφικό σχήμα με τον εξής τρόπο. Σε κάθε bit εισόδου του πίνακα αντιστοιχεί και ένα ζεύγος κλειδιών, ένα για κάθε τιμή που μπορεί να πάρει, αυτά τα συμβολίζουμε ως $k_{x_i^j}$. Δηλαδή αν $\abs{x}=2$ και $\abs{y}=3$ τότε η έξοδος $\mathbf{out}$ για την ανάθεση τιμών $x=01$ και $y=101$ θα κρυπτογραφηθεί ως $Enc_{k_{x_1^0}, k_{x_0^1}, k_{y_2^1}, k_{y_1^0}, k_{y_0^1}}(\mathbf{out})$. Ένα παράδειγμα της μορφής του πίνακα αυτού βρίσκεται στο Σχήμα \ref{fig:yaos-gc-global-truth-table}. Ο $P_1$ αφού έχει ολοκληρώσει τη δημιουργία του κρυπτογραφημένου πίνακα αληθείας, εφαρμόζει ομοιόμορφα τυχαίες μεταθέσεις στις γραμμές του και τον αποστέλλει ολόκληρο στον $P_2$. Οι τυχαίες μεταθέσεις εφαρμόζονται στον πίνακα διότι αν ήταν γνωστή η διάταξη των γραμμών του από τον $P_2$ τότε αυτός αφού θα λάμβανε τα κατάλληλα κλειδία που αντιστοιχούν στην ιδιωτική του είσοδο θα μπορούσε βλέποντας την γραμμή που αντιστοιχεί στα κλειδιά που έχει λάβει να καταλάβει ποια είναι η είσοδος του $P_1$. Ωστόσο, η μετάθεση των γραμμών δημιουργεί ένα άλλο πρόβλημα. Ο $P_2$ θα πρέπει να προσπαθήσει να αποκρυπτογραφήσει κάθε γραμμή του πίνακα προκειμένου να βρει την σωστή στη χειρότερη περίπτωση ενώ κατά μέσο όρο θα πρέπει να προσπαθήσει να αποκρυπτογραφήσει τις μισές γραμμές του πίνακα. Μια γνωστή αποδοτική τεχνική επίλυσης του προβλήματος αυτού ονομάζεται Point-and-Permute \cite{10.1145/100216.100287}, στην οποία θεωρούμε το τελευταίο bit του κάθε κλειδιού ως ένα από τα bit του δείκτη που δείχνει που θα τοποθετηθεί η γραμμή αυτή κατά την μετάθεση. Δηλαδή αν στο παραπάνω παράδειγμα τα τελευταία bit των κλειδιών έχουν τις εξής τιμές :
%
\begin{align*}
    \text{Τελευταίο bit κλειδιού : }k_{x_1^0} = 1, k_{x_0^1} = 0, k_{y_2^1} = 1, k_{y_1^0} = 1, k_{y_0^1} = 0
\end{align*}
%
τότε η γραμμή αυτή θα αποθηκευτεί στην θέση $10110=22$ του πίνακα. Εφόσον έχουμε υποθέσει ότι τα κλειδιά είναι τυχαία επιλεγμένα η μέθοδος αυτή δεν επηρεάζει την ασφάλεια του πρωτοκόλλου. Ο $P_1$ αποστέλλει επίσης στον $P_2$, τα κατάλληλα κλειδιά κρυπτογράφησης $k_{x_i^j}$ για τις τιμές του διανύσματος εισόδου $\mathbf{x}$ που έχει επιλέξει. Δηλαδή στο προηγούμενο παράδειγμα θα στείλει τα κλειδιά $k_{x_1^0}$, $k_{x_0^1}$. Στην συνέχεια αποστέλλει στον $P_2$ τα κλειδιά που αντιστοιχούν στις τιμές του διανύσματος εισόδου $\mathbf{y}$, μέσω $|y|/(2 \cdot |y|)$ Ανυποψίαστης Μεταφοράς. Τέλος ο $P_2$ αφού έχει αποκτήσει όλα τα απαραίτητα κλειδιά για την αποκρυπτογράφηση της γραμμής του Πίνακα Αναζήτησης της $f$ που αντιστοιχεί στο $f(\mathbf{x}, \mathbf{y})$, την αποκρυπτογραφεί, βλέπει το αποτέλεσμα $\mathbf{out}$ και στην συνέχεια το στέλνει στον $P_1$.

\begin{figure}
    \centering
\[
    \begin{pmatrix}
        f(\mathbf{x}=00, \mathbf{y}=000)\\
        f(\mathbf{x}=00, \mathbf{y}=001)\\
        f(\mathbf{x}=00, \mathbf{y}=010)\\
        f(\mathbf{x}=00, \mathbf{y}=011)\\
        \vdots\\
        f(\mathbf{x}=11, \mathbf{y}=110)\\
        f(\mathbf{x}=11, \mathbf{y}=111)\\
    \end{pmatrix}
    \rightarrow
    \begin{pmatrix}
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^0}, k_{y_0^0}}(f(\mathbf{x}=00, \mathbf{y}=000))\\
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^0}, k_{y_0^1}}(f(\mathbf{x}=00, \mathbf{y}=001))\\
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^1}, k_{y_0^0}}(f(\mathbf{x}=00, \mathbf{y}=010))\\
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^1}, k_{y_0^1}}(f(\mathbf{x}=00, \mathbf{y}=011))\\
        \vdots\\
        Enc_{k_{x_1^1}, k_{x_0^1}, k_{y_2^1}, k_{y_1^1}, k_{y_0^0}}(f(\mathbf{x}=11, \mathbf{y}=110))\\
        Enc_{k_{x_1^1}, k_{x_0^1}, k_{y_2^1}, k_{y_1^1}, k_{y_0^1}}(f(\mathbf{x}=11, \mathbf{y}=111))\\
    \end{pmatrix}
\]
    \caption[Παράδειγμα της διαδικασίας κρυπτογράφησης του πίνακα αληθείας της συνάρτησης $f$ σε έναν νέο πίνακα αληθείας με το Πρωτόκολλο Μπερδεμένων Δικτύων Yao.]{Παράδειγμα της διαδικασίας κρυπτογράφησης του πίνακα αληθείας της συνάρτησης $f$ σε έναν νέο πίνακα αληθείας με το Πρωτόκολλο Μπερδεμένων Δικτύων Yao. Ο πίνακας αυτός διαφέρει από τον πραγματικό αφού στον πραγματικό οι γραμμές υπόκεινται σε μετάθεση σύμφωνα με τη τεχνική Point-and-Permute.}
    \label{fig:yaos-gc-global-truth-table}
\end{figure}

\subsubsection{Υπολογισμός με χρήση του Boolean Κυκλώματος της $f$}

Είναι προφανές ότι η παραπάνω μέθοδος δεν μπορεί να κλιμακωθεί σωστά αφού το μέγεθος του Πίνακα Αναζήτησης της $f$ αυξάνεται εκθετικά με το μέγεθος των εισόδων. Μια ιδέα για την επιτάχυνση του υπολογισμού της $f$ από ένα Μπερδεμένο Δίκτυο Yao είναι να την εκφράσουμε ως ένα Boolean Δίκτυο. Από την προσέγγιση αυτή προκύπτει ουσιαστικά και το όνομα αυτού του πρωτοκόλλου. Παρακάτω θα επανεξετάσουμε την αποτίμηση μιας συνάρτησης $f$ από τους δύο συμμετέχοντες $P_1$, $P_2$.

Ο $P_1$ όπως και προηγουμένως είναι αυτός που αναλαμβάνει να αρχικοποιήσει το πρωτόκολλο. Στην προκείμενη περίπτωση να κατασκευάσει το Μπερδεμένο Κύκλωμα. Το κύκλωμα αυτό προκύπτει από το Boolean κύκλωμα της $f$ το οποίο και πρέπει να δημιουργήσει ο $P_1$. Για να το μετατρέψει στο αντίστοιχο Μπερδεμένο Κύκλωμα, δημιουργεί ένα ζεύγος κλειδιών για κάθε καλώδιο του κυκλώματος καθώς και δύο τυχαία συμπληρωματικά bit δεικτοδότησης (παραπλήσια με την τεχνική point-and-permute) για κάθε ζεύγος κλειδιών. Έτσι σε κάθε ζεύγος κλειδιών ενός καλωδίου $i$ αντιστοιχεί η εξής πλειάδα, την οποία ονομάζουμε \textbf{Ετικέτα του καλωδίου} :
%
\[
    w_i^b = (k_i^b \in \bin^\secparam, p_i^b \in \bin) \text{ όπου } p_i^b = 1-p_i^{1-b}
\]
%
Στη συνέχεια ο $P_1$ διατρέχει με το κύκλωμα σύμφωνα με την τοπολογική του διάταξη. Για μια αυθαίρετη πύλη $g_k$ του κυκλώματος, όπως αυτή του Σχήματος \ref{fig:yaos-gc-gate} ανάλογα με το αν είναι πύλη εισόδου, ενδιάμεση ή εξόδου εκτελεί ένα από τα βήματα που εξετάζουμε στη συνέχεια. Η διαφοροποίηση της παραλλαγής αυτής του πρωτοκόλλου σε σχέση με την προηγούμενη παραλλαγή που εξετάσαμε είναι πως για κάθε πύλη του κυκλώματος θα δημιουργήσουμε έναν πίνακα αληθείας. Για να διαχωρίσουμε τους δύο πίνακες θα ονομάσουμε τον πίνακα της προηγούμενης παραλλαγής ολικό πίνακα αληθείας και τον πίνακα αυτής της παραλλαγής τοπικό πίνακα αληθείας. Οι δύο πίνακες αυτοί έχουν μια βασική διαφορά στην κατασκευή τους. Στον τελευταίο η έξοδος κάθε γραμμής είναι η πραγματική έξοδος του κυκλώματος, ενώ στον πρώτο η έξοδος κάθε ενδιάμεσης πύλης είναι ένα μια ετικέτα που περιέχει το κλειδί κρυπτογράφησης που χρησιμοποιείται στην κρυπτογράφηση των γραμμών των πινάκων που λαμβάνουν ως είσοδο την έξοδο αυτή και τα αντίστοιχα bit δεικτοδότησης. Στα σημείο αυτό, για χάριν απλότητας, υποθέτουμε ότι όλες οι πύλες του κυκλώματος διαθέτουν δύο bit εισόδου και ένα bit εξόδου. Προφανώς, ο αλγόριθμος μπορεί πολύ εύκολα να επεκταθεί και για αυθαίρετο αριθμό bit εισόδου και εξόδου. Εναλλακτικά, κατά την αρχικοποίηση του κυκλώματος ο $P_1$ μπορεί πολύ εύκολα μια πύλη αυτού του είδους να αντικατασταθεί με ένα ισοδύναμο συνδυασμό πυλών που αποτελείται μόνο από πύλες με δύο bit εισόδου και ένα bit εξόδου. Τα βήματα που ακολουθεί ο $P_1$ είναι τα εξής :

\begin{itemize}
    \item \textbf{Οποιαδήποτε πύλη} : Στην περίπτωση αυτή, ο $P_1$, για κάθε μία από τις $2^2$ πιθανές (πραγματικές) εισόδους $v_i$, $v_j \in \bin$ της πύλης πρέπει να δημιουργήσει μια γραμμή στον τοπικό πίνακα. Αν θεωρήσουμε $e_{v_i, v_j}$ τη τιμή εξόδου της γραμμής $v_iv_j$ τότε αυτή δημιουργείται ως εξής και τοποθετείται στη θέση $p_i^{v_i}p_j^{v_j}$:
    %
    \[
        e_{v_i, v_j} = Enc_{k_i^{v_i}, k_j^{v_j}, k}(w_k^{g_l(v_a, v_b)})
    \]
    %
    Ένα παράδειγμα μετασχηματισμού του τοπικού πίνακα μιας πύλης φαίνεται στο Σχήμα \ref{fig:yaos-gc-local-truth-table}.
    \begin{figure}[h]
              \centering
              \[
                  \begin{pmatrix}
                      G_l(x=0, y=1)\\
                      G_l(x=0, y=0)\\
                      G_l(x=1, y=0)\\
                      G_l(x=1, y=1)\\
                  \end{pmatrix}
                  \rightarrow
                  \begin{pmatrix}
                      Enc_{k_i^{0}, k_j^{0}, i}(w_k^{g_l(x=0, y=0)})\\
                      Enc_{k_i^{0}, k_j^{1}, i}(w_k^{g_l(x=0, y=1)})\\
                      Enc_{k_i^{1}, k_j^{0}, i}(w_k^{g_l(x=1, y=0)})\\
                      Enc_{k_i^{1}, k_j^{1}, i}(w_k^{g_l(x=1, y=1)})\\
                  \end{pmatrix}
              \]
          \caption[Παράδειγμα της διαδικασίας κρυπτογράφησης του πίνακα αληθείας της συνάρτησης $f$ σε έναν νέο πίνακα αληθείας με το Πρωτόκολλο Μπερδεμένων Δικτύων Yao.]{Παράδειγμα της διαδικασίας κρυπτογράφησης του πίνακα αληθείας της συνάρτησης $f$ σε έναν νέο πίνακα αληθείας με το Πρωτόκολλο Μπερδεμένων Δικτύων Yao. Ο πίνακας αυτός διαφέρει από τον πραγματικό αφού στον πραγματικό οι γραμμές υπόκεινται σε μετάθεση σύμφωνα με τη τεχνική των bit δεικτοδότησης που αναλύσαμε.}
          \label{fig:yaos-gc-local-truth-table}
    \end{figure}
    \item \textbf{Καλώδια εξόδου} : Στην περίπτωση αυτή ακολουθείται ίδια διαδικασία με οποιοδήποτε άλλο καλώδιο μόνο που η τιμή που θα κρυπτογραφήσουμε θα πρέπει να είναι η έξοδος του καλωδίου και όχι κάποιο κρυπτογραφικό κλειδί που χρησιμοποιείται στην αποκρυπτογράφηση των εξόδων των πυλών που δέχονται το καλώδιο εξόδου ως είσοδο. Αν υποθέσουμε ότι η τιμή του καλωδίου εξόδου $w_i$ είναι η $v_i$ τότε τα καλώδια εξόδου δημιουργούνται ως εξής :
    \[
        e_v = Enc_{k_i^v_i, i}(v_i)
    \]
\end{itemize}

\begin{figure}
    \centering
    \begin{circuitikz}
        \draw
        (0,0) node[ieeestd and port](myand){}
        (myand.in 1) node[left]{$w_i^0, w_i^1$}
        (myand.in 2) node[left]{$w_j^0, w_j^1$}
        (myand.out) node[right]{$w_k^0, w_k^1$};
    \end{circuitikz}
    \caption{Παράδειγμα πύλης Μπερδεμένου Δικτύου Yao στην οποία φαίνονται οι δύο ετικέτες του κάθε καλωδίου μιας πύλης.}
    \label{fig:yaos-gc-gate}
\end{figure}

%It is more challenging to make this protocol secure against a malicious adversary that deviates from the protocol. One of the first solutions to make the protocol secure against malicious adversary is to use zero-knowledge proof to prevent malicious activities during the protocol.[11] For years, this approach was considered more as theoretical solution than a practical solution because of complexity overheads of it. But, it is shown that it is possible to use it with just a small overhead.[12] Another approach is using several GC for a circuit and verifying the correctness of a subset of them and then using the rest for the computation with the hope that if the garbler was malicious, it would be detected during the verification phase.[13] Another solution is to make the garbling scheme authenticated such that the evaluator can verify the garbled circuit.[14][15]

\subsection{Πρωτόκολλο Ben-Or, Goldwasser, Wigderson (BGW Protocol)}

Το πρωτόκολλο αυτό προτάθηκε από τους Ben-Or, Goldwasser, Wigderson στην εργασία \cite{BenOr1988CompletenessTF}. Απαιτεί την μοντελοποίηση της $f$ ως ένα Αριθμητικό Δίκτυο σε ένα πεπερασμένο πεδίο $\mathbb{F}$. Στην αρχική του μορφή βασίζεται στη Διαμοίραση Μυστικών Shamir και πιο συγκεκριμένα στις ομομορφικές ιδιότητες που παρουσιάζουν οι μετοχές του (για περισσότερες πληροφορίες σχετικά με τις ομομορφικές ιδιότητες μπορείτε να ανατρέξετε στο Κεφάλαιο \ref{chapter:cryptography} και στο Παράρτημα \ref{chapter:appendix}), ωστόσο μπορούν να χρησιμοποιηθούν και άλλες μέθοδοι διαμοίρασης μυστικών υπό την προϋπόθεση ότι παρουσιάζουν τις ίδιες ομομορφικές ιδιότητες. Όπως αναλύθηκε στο παράρτημα, το SSS είναι προσθετικά ομομορφικό από μόνο του, οπότε κύρια καινοτομία του πρωτοκόλλου BGW είναι η μετατροπή του SSS ώστε να μπορεί είναι και πολλαπλασιαστικά ομομορφικό. Παρακάτω, θα εξετάσουμε τις περιπτώσεις της ομομορφικής πρόσθεσης και πολλαπλασιασμού στην περίπτωση της μιας αριθμητικής πύλης και $n$ συμμετεχόντων και στην συνέχεια θα εξετάσουμε πως μπορούμε να γενικεύσουμε το πρωτόκολλο στην περίπτωση των περισσότερον πυλών. Το πρωτόκολλο αυτό μπορεί να αποδειχθεί ότι είναι ασφαλές ενάντια σε Παθητικούς Αντιπάλους που ελέγχουν τη μειοψηφία των συμμετεχόντων, δηλαδή με διεφθαρμένη μειοψηφία συμμετεχόντων.

Έστω ότι $n$ συμμετέχοντες όπου θέλουν να αποτιμήσουν μια αριθμητική συνάρτηση ή αντίστοιχα ένα αριθμητικό δίκτυο και ας υποθέσουμε όπως και στην Ενότητα \ref{section:yaos-gc}, ότι $out = f(x, y)$, όπου $x$, $y$, είναι οι είσοδοι της συνάρτησης και η καθεμία ελέγχεται από κάποιον συμμετέχον. Η αριθμητική συνάρτηση $f$ πρέπει να είναι γνωστή σε όλους τους συμμετέχοντες. Επίσης, ο κάθε συμμετέχον διαθέτει ένα σημείο $i \in \mathbb{F}$, το οποίο το γνωρίζουν όλοι οι συμμετέχοντες στο δίκτυο, το οποίο χάριν απλότητας ας υποθέσουμε ότι το $i$ είναι ο αύξων αριθμός του συμμετέχοντος και $i = 0, \ldots, n-1 \in \mathbb{F}$. Στην συνέχεια της ενότητας, ο συμβολισμός $i$ θα χρησιμοποιείται για να αναφερθούμε είτε στο σημείο του παίχτη $i$ είτε στον ίδιο τον παίχτη $i$. Στην συνέχεια ανάλογα με την πύλη του αριθμητικού κυκλώματος εκτελείται ένα μια από τις παρακάτω διαδικασίες :

\begin{itemize}
    \item \textbf{Καλώδιο Εισόδου} : Στην περίπτωση της εισόδου, ο συμμετέχον, ας τον ονομάσουμε $P$, που ελέγχει την είσοδο είσοδο, ας την ονομάσουμε $x$, διαμοιράζει μέσω $SSS(n,t)$ την τιμή της $x$, υπό τον περιορισμό ότι $2t + 1 < n$ (θα αιτιολογηθεί στην συνέχεια ο περιορισμός αυτός) και δίνει αντίστοιχες μετοχές $[x]_i$ σε κάθε άλλον συμμετέχον $i \in 0, 1, \ldots n$. Όπως γνωρίζουμε από το $SSS$, η μετοχή του παίχτη $i$ είναι ένα σημείο $(i, p_x(i))$, για την είσοδο $x$ και το $p_x$ είναι το πολυώνυμο $t$-οστού βαθμού που επέλεξε ο συμμετέχον $P$.
    \item \textbf{Πύλη Πρόσθεσης} : Στην περίπτωση αυτή, υποθέντωντας ότι έχουμε μια πύλη πρόσθεσης με δύο εισόδους, τότε κάθε συμμετέχον $i$ διαθέτει μια μετοχή $[x]_i$ και μια $[y]_i$ αντίστοιχα. Κάθε συμμετέχον μπορεί να εκτελέσει την πράξη $x+y$, απλώς αθροίζοντας τις τετμημένες των αντίστοιχων μετοχών, δηλαδή $[c]_i = [x]_i + [y]_i$. Το παραπάνω προκύπτει από την ιδιότητα της γραμμικότητας του $SSS$ που αναλύθηκε στο Κεφάλαιο \ref{chapter:cryptography}, αφού προκύπτει ότι $[c]_i = [x]_i + [y]_i = p_x(i) + p_y(i) = p_{x+y}(i) = [x + y]_i$. Η πράξη της πρόσθεσης δεν απαιτεί καμία αλληλεπίδραση μεταξύ των συμμετεχόντων αφού ο καθένας τους διαθέτει τις μετοχές $[x]_i$ και $[y]_i$.
    \item \textbf{Πύλη Πολλαπλασιασμού} :
        \begin{itemize}
            \item \textbf{Βαθμωτός πολλαπλασιασμός} : Παρόμοια με την πράξη της πρόσθεσης από την γραμμική ιδιότητα του $SSS$ προκύπτει ότι $[c]_i = b \cdot [x]_i = b \cdot p_x(i) = p_{b \cdot x}(i) = [b \cdot x_i ]$.
            \item \textbf{Πολλαπλασιασμός με μεταβλητή} : Κάθε συμμετέχον $i$ διαθέτει μια μετοχή $[x]_i$ και μια $[y]_i$ αντίστοιχα. Όπως και με τους υπόλοιπους τελεστές αρχικά ο κάθε συμμετέχον υπολογίζει την μετοχή $[c]_i = [x]_i \cdot [y]_i$. Γνωρίζουμε ότι $[c]_i = [x]_i \cdot [y]_i = p_x(i) \cdot p_y(i) = p_{x \cdot y}(i) (= p_c(i))= [x \cdot y]_i$. Όπως παρατηρούμε το πρόβλημα που προκύπτει στην πράξη του πολλαπλασιασμoύ είναι ότι ο πολλαπλασιασμός δύο πολυωνύμων $t$-οστού βαθμού, όπως στην προκείμενη περίπτωση των $p_x$ και $p_y$, μπορεί να μας δώσει ως αποτέλεσμα ένα πολυώνυμο μέχρι και $2t$-οστού βαθμού. Είναι απαραίτητο να κρατήσουμε σταθερό αυτό το κατώφλι $t$. Για να το επιτύχουμε αυτό αρχικά ο κάθε συμμετέχον εκτελεί τον πολλαπλασιασμό των μετοχών $[c]_i = [x]_i \cdot [y]_i$, όπως προαναφέραμε. Στο σημείο αυτό, εξετάζουμε την χειρότερη περίπτωση, δηλαδή ότι το $[c]_i$ έχει κατώφλι διαμοίρασης $2t$. Για να μειωθεί το κατώφλι σε $t$, ο κάθε συμμετέχον $i$ διαμοιράζει το $[c]_i$ με $SSS(n, t)$, ας υποθέσουμε ότι χρησιμοποιεί για αυτό ένα τυχαίο πολυώνυμο $p_{h_i}(x)$ όπου προφανώς $p_{h_i}(0)=[c]_i=p_c(i)$, και στην συνέχεια διαμοιράζει τις μετοχές που αντιστοιχούν στον καθένα από τους υπόλοιπους $n-1$ συμμετέχοντες. Δηλαδή, στον παίχτη $j$ ο παίχτης $i$ θα στείλει την τιμή $p_{h_i}(j)$. Έτσι, ο κάθε συμμετέχον $j$ διαθέτει τις μετοχές $p_{h_i}(j)$ για κάθε $i \in 1, 2, \ldots, n$. Στην συνέχεια κάθε συμμετέχον υπολογίζει την τελική του μετοχή ως εξής :
            
            \begin{equation}\label{eq:bgw1}
            p_h(j) = \sum_{i=1}^{2t+1}λ_i(x)p_{h_i}(j)
            \end{equation}
            
            όπου $λ_i$ είναι ο κατάλληλος συντελεστής που αναφέρεται στο παράρτημα και μπορεί να υπολογιστεί από κάθε συμμετέχοντα αφού είναι δημόσια γνωστό στους συμμετέχοντες ότι $α_i=i$. Επειδή, η ορθότητα της Σχέσης \ref{eq:bgw1} ίσως να μην είναι προφανής ας σταθούμε λίγο περισσότερο σε αυτήν. Η Σχέση \ref{eq:bgw1} μπορεί να αναπτυχθεί στην παρακάτω :
            $$            
                 p_h(j) = \sum_{i=1}^{2t+1}λ_i(x)p_{h_i}(j) = λ_1p_{h_1}(j) + λ_2p_{h_2}(j) + \ldots + λ_n p_{h_n}(j)
            $$
            και ουσιαστικά το πολυώνυμο $p_h(x)$ του οποίου σημείο είναι το $p_h(j)$ είναι το παρακάτω : 
            $$
                p_h(x) = λ_1p_{h_1}(x) + λ_2p_{h_2}(x) + \ldots + λ_n p_{h_n}(x)
            $$
            Ισχύει ότι $deg(p_h(x))=t$ αφού είναι άθροισμα των πολυωνύμων $p_{h_i}$ για καθένα από τα οποία ισχύει $deg(p_{h_i} = t)$. Επίσης, μπορούμε να επαληθεύσουμε ότι $p_h(0)=p_c(0)$ αφού
            
            \begin{align}
                p_h(0) &= λ_1 p_{h_1}(0) + λ_2 p_{h_2}(0) + \ldots + λ_n p_{h_n}(0) \\
                &= λ_1 p_c(1) + λ_2 p_c(2) + \ldots + λ_n p_c(n) \\
                &= p_c(0)
            \end{align}
        \end{itemize}
    \item \textbf{Καλώδιο Εξόδου} : Στην περίπτωση αυτή το μόνο που έχουν να κάνουν οι συμμετέχοντες είναι να ανοίξουν τις μετοχές τους όπως περιγράφεται στο Πρωτόκολλο SSS, στο Κεφάλαιο \ref{chapter:cryptography}.
\end{itemize}

\subsubsection{Επιτάχυνση του πρωτοκόλλου με χρήση Πολλαπλασιαστικών Τριάδων Beaver (Beaver Triples)}
Στο πρωτόκολλο BGW, στην περίπτωση του πολλαπλασιασμού που έχει προκύψει από είσοδο, κάθε παίχτης πρέπει να εκτελέσει $SSS(n,t)$ και δηλαδή να διαμοιράσει $n$ μετοχές. Αυτό έχει πολυπλοκότητα επικοινωνίας $O(n^2)$. Μπορούμε να βελτιώσουμε την παραπάνω πολυπλοκότητα επικοινωνίας αν χωρίσουμε τον υπολογισμό σε δύο φάσεις, την \textbf{Φάση προεπεξεργασίας (Preprocessing phase)} και την \textbf{Online φάση}. Έτσι μπορούμε να επιτύχουμε βελτίωση της πολυπλοκότητας επικοινωνίας με τον εξής τρόπο. Η επιτάχυνση μπορεί να συμβεί με τον παρακάτω τρόπο.

Ας υποθέσουμε ότι $x$ και $y$ είναι οι είσοδοι της πολλαπλασιαστικής πύλης για τις οποίες κάθε συμμετέχον διαθέτει μετοχές $[x]$ και $[y]$ αντίστοιχα. Επίσης έστω οι τιμές $a, b \sample \mathbb{F}$, $c=a \cdot b$ και οι αντίστοιχες μετοχές $[a]$, $[b]$, $[c]$ τους. Τότε ο κάθε συμμετέχον μπορεί να υπολογίσει την πολλαπλασιαστική πύλη ακολουθώντας τα παρακάτω βήματα :

\begin{enumerate}
    \item Υπολογίζει τα $[x - a]$ και $[y - b]$ και ανακοινώνει δημόσια τις τιμές $d = x - a$ και $e = y - b$.
    \item Υπολογίζει το $de + d[b] + e[a] + [c] = [x \cdot y]$ αφού,
    \begin{align}
        xy &= (x - a + a)(y - a + a) \\
           &= (d + a)(d + b) \\
           &= de + db + ae + ab \\
           &= de + db + ae + c
    \end{align}
\end{enumerate}

Τέλος, να σημειώσουμε ότι ο διαχωρισμός του πρωτοκόλλου σε περισσότερες από μία φάσεις είναι κάτι πολύ σύνηθες στην περίπτωση των SMPC και FHE πρωτοκόλλων, που αποσκοπεί συνήθως στην εξοικονόμηση χρονικής ή χωρικής πολυπλοκότητας κάθε φάσης μέσω των προηγούμενων της. Μια τέτοια περίπτωση αποτελεί και το πρωτόκολλο SPDZ που θα εξετάσουμε σε επόμενη ενότητα.

\subsection{Πρωτόκολλο Goldreich, Micali, Wigderson (GMW Protocol)}

Το πρωτόκολλο αυτό προτάθηκε από τους Goldwasser, Micali, Wigderson στην εργασία \cite{goldreich2019play} το 1987. Απαιτεί την αναπαράσταση του υπολογισμού μιας συνάρτησης, $f$, ως Boolean κύκλωμα. Το πρωτόκολλο αυτό μοιάζει σε ένα βαθμό, με αυτό των Μπερδεμένων Δικτύων Yao, που περιγράψαμε προηγουμένως. Οι συμμετέχοντες έχουν ένα Boolean δίκτυο το οποίο αποτιμούν πύλη ανά πύλη (gate-by-gate) σύμφωνα με την τοπολογική τους σειρά. Ένα ακόμα κοινό χαρακτηριστικό, είναι ότι και το GMW χρησιμοποιεί OT για τον υπολογισμό ορισμένων Boolean πυλών. Σε αυτό το χαρακτηριστικό βασίζεται και η κύρια διαφορά των δύο πρωτοκόλλων. Το GMW απαιτεί ΟΤ μόνο στην περίπτωση της AND πύλης, ενώ οι πύλες NOT και XOR μπορούν να υπολογιστούν χωρίς OT. Το γεγονός αυτό κάνει το GMW κατά μέσο όρο πιο γρήγορο από τo Yao's GC. Μια ακόμα διαφορά τους είναι πως το πρωτόκολλο αυτό επιτρέπει την την συμμετοχή περισσότερων των δύο συμμετεχόντων στον υπολογισμό. Στην συνέχεια, θα επικεντρωθούμε στην περίπτωση των δύο συμμετεχόντων, ενώ θα αναφερθούμε λίγο αργότερα στο πως αυτή μπορεί να γενικευθεί σε για περισσότερους. Το πρωτόκολλο αυτό είναι ασφαλές ενάντια σε Παθητικούς αντιπάλους.

Θα εξετάσουμε την περίπτωση δύο συμμετεχόντων, $P_1$ και $P_2$, και μιας Boolean πύλης όπως αυτή του Σχήματος \ref{fig:gmw-gate} με δύο bit εισόδου και ένα bit εξόδου :
\begin{itemize}
    \item \textbf{Καλώδιο εισόδου} : Έστω πως ο συμμετέχον $P_1$ διαθέτει ένα ιδιωτικό bit εισόδου $x_i$ το οποίο αντιστοιχεί σε ένα καλώδιο $w_i$ του κυκλώματος. Έστω επίσης $s_i^j$, η μετοχή για το καλώδιο $w_i$ του παίχτη $j$. Για κάθε καλώδιο $i$ επιθυμούμε $s_i^j \oplus s_i^{j-1} = w_i$. Ο $P_1$ δημιουργεί τις μετοχές ως εξής :
    \begin{itemize}
        \item Στέλνει στον $P_2$ το $r_i \sample \bin$, η οποία είναι η μετοχή του $P_2$ για το καλώδιο $w_i$, δηλαδή $s_i^2 = r_i$
        \item Δημιουργεί τη δική του μετοχή του $w_i$ ως εξής : $s_i^1 = x_i \oplus r_i$
    \end{itemize}
    Ο σκοπός αυτού του τρόπου διαμοίρασης μετοχών είναι πως για κάθε καλώδιο η πραγματική του τιμή είναι η $w_i = s_i^1 \oplus s_i^2$. Ο λόγος για τον οποίο χρησιμοποιείται η πύλη XOR για τη διαμοίραση είναι πως
    \item \textbf{Πύλη NOT} : Έστω το καλώδιο εισόδου $w_k$ και το καλώδιο εξόδου $w_{k+1}$. Στην περίπτωση της Πύλης NOT, ένας από τους δύο συμμετέχοντες (όχι και οι δύο) τον οποίο πρέπει είτε να έχουν προαποφασίσει είτε εναλλακτικά να ρίξουν κάποιο τυχαίο νόμισμα μέσω Ανυποψίαστης Μεταφοράς, έστω ο $P_1$, το μόνο που έχει να κάνει είναι να αντιστρέψει το bit της μετοχής του, δηλαδή $s_{k+1}^1 = 1-s_k^1$
    \item \textbf{Πύλη XOR} : Έστω τα καλώδια εισόδου $w_k$, $w_{k+1}$ και το καλώδιο εξόδου $w_{k+2}$. Στην περίπτωση της Πύλης XOR, οι δύο συμμετέχοντες κάνουν XOR τις μετοχές που έχουν για κάθε μία από τις δύο εισόδους της πύλης. Δηλαδή $s_{k+2}^1 = s_{k}^1 \oplus s_{k+1}^1$ και $s_{k+2}^2 = s_k^2 \oplus s_{k+1}^2$
    \item \textbf{Πύλη AND}: Έστω τα καλώδια εισόδου $w_k$, $w_{k+1}$ και το καλώδιο εξόδου $w_{k+2}$. Στην περίπτωση της Πύλης AND, ο ένας από τους δύο συμμετέχοντες, έστω ο $P_1$ πρέπει να ετοιμάσει ένα 1-4 ΟΤ της παρακάτω συνάρτησης :
    \[
    S=S_{s_i^1, s_j^1}\left(s_i^2, s_j^2\right)=\left(s_i^1 \oplus s_i^2\right) \wedge\left(s_j^1 \oplus s_j^2\right)
    \]
    Αυτό το κάνει επιλέγοντας $r \sample \bin$ και στη συνέχεια δημιουργώντας τον παρακάτω πίνακα από τον οποία στέλνει την κατάλληλη γραμμή μέσω 1-4 OT ανάλογα με τη τιμή που έχουν οι μετοχές του $P_2$ :
    \[
    T_G=\left(\begin{array}{l}
                  r \oplus S(0,0) \\
                  r \oplus S(0,1) \\
                  r \oplus S(1,0) \\
                  r \oplus S(1,1)
    \end{array}\right)
    \]
    \item \textbf{Καλώδιο εξόδου} :
\end{itemize}

\begin{figure}
    \centering
    \begin{circuitikz}
        \draw
        (0,0) node[ieeestd and port](myand){}
        (myand.in 1) node[left]{$s_i^0, s_i^1$}
        (myand.in 2) node[left]{$s_j^0, s_i^1$}
        (myand.out) node[right]{$w_k^0, w_k^1$};
    \end{circuitikz}
    \caption{Παράδειγμα πύλης για το πρωτόκολλο GMW στη περίπτωση των δύο συμμετεχόντων}{Παράδειγμα πύλης για το πρωτόκολλο GMW στη περίπτωση των δύο συμμετεχόντων. Σε κάθε καλώδιο σημειώνονται οι δύο μετοχές που κρατάνε οι συμμετέχοντες για αυτό.}
    \label{fig:gmw-gate}
\end{figure}

\section{Ασφαλής Υπολογισμός Πολλών Μερών ενάντια σε Ενεργητικούς Αντιπάλους}

Η ενότητα αυτή δεν εμπίπτει πλήρως στους σκοπούς αυτής της εργασίας από την πρακτική σκοπιά αφού η βιβλιοθήκη MPC-BLAS δημιουργήσαμε και θα αναλύσουμε στο επόμενο κεφάλαιο είναι ασφαλής ενάντια σε Παθητικούς αντιπάλους. Ωστόσο, ο κλάδος αυτός πρόκειται για έναν από τους πιο ερευνητικά ενεργούς υποκλάδους του SMPC και θεωρούμε παράλειψη να μην αναφερθούμε σε αυτόν.  Γενικότερα, δημιουργία πρωτοκόλλων Ασφαλούς Υπολογισμού ασφαλή ενάντια σε Ενεργητικούς αντιπάλους δεν αποτελεί μια εύκολη υπόθεση. Για την επίτευξη αυτού του σκοπού έχουν αναπτυχθεί διάφορες τεχνικές τις οποίες θα εξετάσουμε συνοπτικά στην επόμενη ενότητα κια αμέσως μετά θα αναλύσουμε το πρωτόκολλο SPDZ που επιτυγχάνει το σκοπό αυτό.

\subsection{Τεχνικές Μετατροπής μετατροπής της ασφάλειας πρωτοκόλλων από Παθητική σε Ενεργητική}

Οι μεθοδολογίες που ακολουθούνται όταν θέλουμε να δημιουργήσουμε ένα πρωτόκολλο που να είναι ασφαλές ενάντια σε ενεργητικούς στη βιβλιογραφία χωρίζονται κυρίως σε δύο κύριες κατηγορίες. Στην πρώτη περίπτωση η αφετηρία μας είναι ένα πρωτόκολλο ασφαλές ενάντια σε παθητικούς αντιπάλους το οποίο στην συνέχεια μέσω τεχνικών προσπαθούμε να κάνουμε ασφαλές ενάντια σε ενεργητικούς αντιπάλους. Μερικές από τις τεχνικές που εφαρμόζονται είναι οι εξής :

\begin{itemize}
    \item Cut-and-Choose \cite{chaum1984blind}
    \item Μεταγλωττιστής GMW \cite{goldreich2019play}
    \item Αυτθεντικοποιημένα Μπερδεμένα Δίκτυα \cite{wang2017authenticated}
\end{itemize}

Οι εναλλακτικές μέθοδος που μπορούμε να ακολουθήσουμε είναι να προσπαθήσουμε να δημιουργήσουμε ένα πρωτόκολλο ασφαλούς ενάντια σε ενεργητικούς αντιπάλους υποθέτοντας πως κάποια κρίσιμα κομμάτια του υλοποιούνται με κάποιο ιδανικό τρόπο, για παράδειγμα μέσω ενός έμπιστου τρίτου. Αυτός ο τρόπος, μας επιτρέπει να προχωρήσουμε τη διαδικασία σχεδίασης του πρωτοκόλλου. Στο τέλος της διαδικασίας προσπαθούμε να αντικαταστήσουμε τον έμπιστο τρίτο με κάποιο πρωτόκολλο ασφαλές ενάντια σε ενεργητικούς αντιπάλους ή παθητικούς αντιπάλους που να εκτελεί την διεργασία του. Αυτό τον τρόπο ακολουθεί και το πρωτόκολλο SPDZ που θα εξετάσουμε στη συνέχεια.

\subsection{Πρωτόκολλα Ασφαλή ενάντια σε Ενεργητικούς Αντιπάλους}

Η Online φάση του πρωτοκόλλου SPDZ όπως προαναφέραμε είναι ασφαλής ενάντια σε ενεργητικούς αντιπάλους που ελέγχουν διεφθαρμένη πλειοψηφία των συμμετεχόντων. Είναι σημαντικό να αναφέρουμε πως στη περίπτωση αυτή έχει αποδειχθεί ότι δεν μπορούν να υπάρξουν απόλυτα ασφαλή SMPC πρωτόκολλα, παρά μόνο υπολογιστικά ασφαλή πρωτόκολλα.

\subsection{Πρωτόκολλο SPDZ}

Το πρωτόκολλο SPDZ παρουσιάστηκε για πρώτη φορά το 2011 στην εργασία \cite{cryptoeprint:2011/535} και είναι άμεσα επηρεασμένο από την \cite{bendlin2011semi} που παρουσιάστηκε την ίδια χρονιά και υπήρξαν αρκετά κοινά μέλη στις δύο αυτές ερευνητικές ομάδες αλλά και από την \cite{ishai2007zero}. Το SPDZ απαιτεί την αναπαράσταση μια συνάρτησης $f$ που θέλουν να αποτιμήσουν οι συμμετέχοντες ως αριθμητικό δίκτυο. Το πρωτόκολλο, χωρίζεται σε δύο φάσεις, αυτή της Προεπεξεργασίας ή Offline(Preprocessing ή Offline phase) και την Online φάση (Online phase). Η πρώτη είναι ασφαλής ενάντια σε παθητικούς αντιπάλους ενώ η δεύτερη είναι ασφαλής ενάντια σε ενεργητικούς αντιπάλους. Δυστυχώς, δεν μπορούμε να καλύψουμε λεπτομερώς τη φάση προεπεξεργασίας διότι βασίζεται στην Κάπως Ομομορφική Κρυπτογραφία. Από τότε που προτάθηκε το SPDZ, έχουν υπάρξει διάφορες προτάσεις/βελτιώσεις του στη βιβλιογραφία οι οποίες κυρίως βελτιώνουν το κομμάτι της Προεπεξεργασίας, μερικές από αυτές είναι οι MASCOT. Σήμερα, με το όνομα SPDZ αναφερόμαστε γενικότερα στην κλάση των πρωτοκόλλων που βασίζονται στην εργασία \cite{cryptoeprint:2011/535}. Στην παράγραφο αυτή θα αναλύσουμε το πρωτόκολλο που προτάθηκε στην εργασία αυτή. Πριν ξεκινήσουμε με την ανάλυση του πρωτοκόλλου πρέπει πρώτα να σταθούμε στη σημειογραφία που χρησιμοποιείται σε αυτό.

\subsubsection{Σημειογραφία πρωτοκόλλου SPDZ}

Στα πλαίσια του πρωτοκόλλου αυτού όταν αναφερόμαστε σε Διαμοίραση Μυστικών εννοούμε Προσθετική Διαμοίραση Μυστικών. Το εργαλείο αυτό βρίσκεται στη καρδιά του SPDZ. Παρότι δεν το έχουμε ορίσει μέχρι στιγμής στην εργασία αυτή, λειτουργεί πολύ απλά. Κάθε μετοχή αποτελεί μια τιμή όπου το άθροισμα όλων των μετοχών αποκαλύπτουν το μυστικό της διαμοίρασης, δηλαδή είναι μια διαμοίραση με κατώφλι $n-n$, αν υποθέσουμε ότι έχουμε $n$ συμμετέχοντες. Υποθέτοντας ότι έχουμε $n$ συμμετέχοντες στο πρωτόκολλο, τότε κάθε τιμή ενός καλωδίου $x$ είναι διαμοιρασμένη σε όλους τους παίχτες. Συνολικά η τιμή $x$ περιγράφεται από την παρακάτω πλειάδα
\begin{equation}
\label{def:spdz-secret}
[ x ] = (δ, x^{1}, \ldots, x^{n}, m^{1} = γ_Δ(x^1), \ldots, m^{n} = γ_Δ(x^n), Δ^{1}, \ldots, Δ^{n})
\end{equation}
όπου ισχύουν οι εξής ιδιότητες :
\begin{equation}
    \label{def:spdz-secret-properties}
x=\sum_{i=1}^n x^{i}, x \cdot Δ + δ=(\sum_{i=1}^n m^{i}), \Delta=\sum_{i=1}^n \Delta^{i}
\end{equation}
Τον ρόλο της μεταβλητής $δ$ θα τον δούμε στην συνέχεια, η τιμή της στην αρχή του πρωτοκόλλου συνήθως είναι 0. Ο τιμές $x^i$ είναι οι προσθετικές μετοχές της $x$, οι τιμές $m_i$ είναι η προσθετικές μετοχή του σχήματος MAC και οι τιμές $Δ_i$ είναι οι προσθετικές μετοχές του σχήματος MAC. Το σχήμα MAC στην συγκεκριμένη περίπτωση, δεν σχετίζεται με τα σχήματα MAC που βασίζονται σε συμμετρικά κρυπτογραφικά σχήματα. Ορίζεται ως εξής :
\[
    m = \operatorname{MAC}_k(x) = γ_k(x) = k \cdot x \mod p \text{ , όπου $p$ πρώτος με το κατάλληλο μέγεθος.}
\]
Δηλαδή, από την Σχέση \ref{def:spdz-secret}, για κάθε καλώδιο, έστω $x$, του κυκλώματος ο κάθε συμμετέχον $P_i$ έχει στην κατοχή του την εξής πλειάδα :
\[
    [x]_i = (x^i, γ_Δ(x^i), Δ^i) \text{ για τα οποία ισχύει : } m_i = γ_Δ(x_i) = Δ_i \cdot x_i
\]
Στο σημείο αυτό να αναφέρουμε πως οι μετοχές για την τιμή $Δ$ δεν μεταβάλλονται από μετοχή σε μετοχή. Τις αναφέραμε για μεγαλύτερη πληρότητα της περιγραφής της μετοχής. Οι τιμές αυτές χρησιμοποιούνται μόνο όταν είναι να αποτιμηθούν οι έξοδοι του πρωτοκόλλου, οπότε θα τις παραλείπουμε στην περιγραφή μιας μετοχής και θα επανέλθουμε σε αυτές όταν θα αναλύσουμε αυτό το στάδιο του πρωτοκόλλου.

Στην περίπτωση πρόσθεσης μιας σταθεράς, έστω $ε$, σε μια μετοχή, έστω $[x]$, τότε αυτή εκτελείται ως εξής :
\[
    [x]' = ε+[x] = [ε + x] = (δ-ε, x^1+ε, x^2, \ldots, x^n, γ_Δ(x^1), γ_Δ(x^2), \ldots, γ_Δ(x^n))
\]
Παρατηρούμε ότι στην περίπτωση αυτή διατηρούνται οι ιδιότητες της Σχέσης \ref{def:spdz-secret-properties}, αφού :
\begin{equation}
    \begin{gathered}
    x'=\sum_{i=1}^n x^{i} + ε = x+ε\\
    x' \cdot Δ = (x'+ ε + δ) \cdot Δ = (x + ε - ε) \cdot Δ = x \cdot Δ\\
    \end{gathered}
\end{equation}
Παρατηρούμε επίσης ότι μόνο ένας συμμετέχον, επιλέξαμε αυθαίρετα τον $P_1$ θα προσθέσει την σταθερά στην μετοχή του, δηλαδή την $[x]_1$.
\subsubsection{Φάση Προεπεξεργασίας (Preprocessing phase)}

Η φάση αυτή αποτελείται από ένα πρωτόκολλο που εκτελείται μεταξύ όλων των συμμετεχόντων χωρίς να είναι απαραίτητο να έχουν επιλεγεί οι είσοδοι από τους συμμετέχοντες. Ο σκοπός της φάσης αυτής είναι η δημιουργία επαρκούς πλήθους πολλαπλασιαστικών τριάδων Beaver, δηλαδή $[a], [b], [c]$ όπου $c = a \cdot b$ και επαρκούς πλήθος ομοιόμορφα τυχαίων διαμοιρασμένων τιμών $[r]$.

Οι τιμές που παράγονται στη φάση αυτή διαφοροποιούνται ελαφρώς σε σχέση με αυτές που χρησιμοποιούνται στην online φάση και έχουν την εξής μορφή και σημειογραφία :
\[
[[ a ]]=((a_1, \ldots, a_n),(b_i, γ(a)_1^i, \ldots, γ(a)_n^i)_{i=1, \ldots, n}))
\]
όπου
\[
    a = \sum_i a_i \text{ και } ab_i = \sum_j γ(α)_i^j
\]
Ένα παίχτης $P_i$ για την $[[a]]$ έχει στη κατοχή του τα εξής :
\[
    [[a]]_i = ((a_1, \ldots, a_n), (b_i, γ_{b_i}(a)_1^i, \ldots, γ_{b_i}(a)_n^i))
\]
Η γενικότερη ιδέα είναι πως $γ_{b_i}(a)_i = \sum_jγ(a)_i^j$ είναι το MAC που αυθεντικοποιεί την τιμή $a$ υπό το ιδιωτικό κλειδί, $b_i$, του $P_i$.

\subsubsection{Online φάση (Online phase)}

Έστω $n$ συμμετέχοντες, όπου τον καθένα συμβολίζουμε με $P_i$, $i=1, \ldots, n$.

\begin{itemize}
    \item \textbf{Καλώδιο εισόδου} : Έστω ο παίχτης $P_i$ θέλει να εισάγει μια είσοδο $x_i$. Τότε παίρνει ένα ζεύγος $[r]$, $[[r]]$ και εκτελεί το παρακάτω :
    \begin{enumerate}
        \item Το $[[r]]$ ανοίγεται στον $P_i$.
        \item Στέλνει το $ε \gets x_i - r$ σε όλους τους υπόλοιπους συμμετέχοντες.
        \item Ο κάθε συμμετέχον θέτει τη μετοχή του για το $x_i$ ως εξής : $[x]_i \gets [r] + ε$
    \end{enumerate}
    \item \textbf{Πύλη πρόσθεσης} : Έστω ότι η πύλη διαθέτει δύο εισόδους $x$, $y$ και έξοδο $w$. Τότε αυτή μπορεί να υπολογιστεί χωρίς αλληλεπίδραση με τον κάθε συμμετέχοντα να θέτει τη μετοχή του $[w]_i = [x]_i + [y]_i$.
    \item \textbf{Πύλη πολλαπλασιασμού} : Έστω ότι η πύλη διαθέτει δύο εισόδους $x$, $y$ και έξοδο $w$. Τότε οι συμμετέχοντες χρησιμοποιούν δύο τριάδες Beamer, ας τις ονομάσουμε $([a], [b], [c])$ και $[f], [g], [h]$ και εκτελούν :
    \begin{enumerate}
        \item Ανοίγεται μια δημόσια τυχαία τιμή $[[t]]$.
        \item Ανοίγεται μερικώς η τιμή $ρ = t \cdot [a] - [f]$ και η τιμή $σ=[b]-[g]$.
        \item Αποτιμάται η τιμή $t \cdot [c] - [h] - σ \cdot [f] - ρ \cdot [g] - σ \cdot ρ$ απο κάθε συμμέχον και ανοίγεται μερικώς το αποτέλεσμα.
        \item Αν το αποτέλεσμα δεν είναι μηδέν τότε ακυρώνεται η εκτέλεση, αν είναι μηδέν τότε ο κάθε συμμετέχον υπολογίζει την μετοχή $[w]_i$ ως εξής :
        \[
            [w]_i = [c]_i + ε \cdot [b]_i + δ \cdot [a]_i + ε \cdot δ
        \]
    \end{enumerate}
    \item \textbf{Καλώδιο εξόδου} : Έστω ένα καλώδιο εξόδου $y$ με αντίστοιχη μετοχή $[y]$, τότε οι συμμετέχοντες εκτελούν τα εξής βήματα :
    \begin{enumerate}
        \item Έστω $a^1, \ldots a^T$ όλες οι τιμές που έχουν ανοιχτεί δημόσια μέχρι στιγμής, τότε ανοίγεται μια τυχαία τιμή $[[e]]$. Τότε
        \item Ο κάθε συμμετέχον $P_i$ δεσμεύεται στις εξής τιμές $γ_i = \sum_j e_j \cdot γ_Δ(a_j)_i$, $y_i$, $γ_Δ(y)_i$.
        \item Η τιμή $Δ$ ανοίγεται.
        \item Ο κάθε παίχτης $P_i$ δεσμεύεται στις τιμές $γ_i = \sum_j e_jγ_Δ(a_j)_i$, $y_i$, $γ_Δ(y)_i$.
        \item Για να ληφθεί η τελική τιμή $y$ της εξόδου, οι δεσμεύσεις $y_i$ και $γ_Δ(y)_i$ ανοίγονται δημόσια. Κάθε παίχτης ελέγχει αν $γ_Δ(y+δ) = \sum_i γ_Δ(y)_i$ και αν ισχύει η ισότητα τότε το η έξοδος είναι $y = \sum_i y_i$ διαφορετικά απορρίπτεται το αποτέλεσμα.
    \end{enumerate}
\end{itemize}