\chapter{Ασφαλής Υπολογισμός Πολλών Μερών}
\label{chapter:SMPC}

Στην ενότητα αυτή θα γίνει μια εισαγωγή στον Ασφαλή Υπολογισμό Πολλών Μερών (Secure Multi Party Computation ή (SMPC)) και στη συνέχεια θα περιγραφούν και θα αναλυθούν ορισμένα βασικά πρωτόκολλα που χρησιμοποιούνται μέχρι και σήμερα. Σχετικά με την ανάλυση των πρωτοκόλλων θα ξεκινήσουμε από τα πιο απλά και ιστορικά που είναι ασφαλή ενάντια σε παθητικούς αντιπάλους και θα συνεχίσουμε προς τα πιο σύνθετα και σύγχρονα που είναι ασφαλή ενάντια σε ενεργητικούς αντιπάλους. Δυστυχώς, παρότι σε κάποια πρωτόκολλα ίσως είναι προφανής η ιδιότητα της ασφάλεια τους για συγκεκριμένα μοντέλα αντιπάλων, η πλήρης τυποποιημένη απόδειξη της ασφάλειας αυτής για όλα τα πρωτόκολλα που θα αναλύσουμε θα χρειαζόταν τουλάχιστον κάποιες δεκάδες σελίδες σελίδες παραπάνω και θα ξέφευγε από τα πλαίσια της εργασίας αυτής. Ωστόσο, η μεθοδολογία που περιγράψαμε στο Κεφάλαιο \ref{chapter:security} καθώς και η παρατιθέμενη βιβλιογραφία δίνει ένα καλό εναρκτήριο σημείο για τον αναγνώστη που θέλει να εντρυφήσει στις αποδείξεις αυτές. Τα πρωτόκολλα που θα περιγράψουμε στο κεφάλαιο αυτό είναι τα Μπερδεμένα Δίκτυα Yao, BMR, GMW και SPDZ. Τα πρώτα τρία πρωτόκολλα υποστηρίζονται από τη βιβλιοθήκη ABY που χρησιμοποιούμε στο υλοποιητικό κομμάτι αυτής της εργασίας που βρίσκεται στο Κεφάλαιο \ref{chapter:implementation}. Είναι και τα τρία ασφαλή ενάντια σε παθητικούς αντιπάλους. Το τελευταίο πρωτόκολλο είναι ένα από τα πιο σύγχρονα και επιτυχημένα πρωτόκολλα που έχουν προταθεί στη βιβλιογραφία και παρότι δε σχετίζεται με την υλοποίηση επιλέξαμε να το αναλύσουμε για να υπάρχει σφαιρικότερη κάλυψη της βιβλιογραφίας, αφού είναι ασφαλές ενάντια σε ενεργητικούς αντιπάλους.

Στο Κεφάλαιο \ref{chapter:intro} κάναμε μια πολύ μικρή εισαγωγή στον κλάδο SMPC. Τα SMPC είναι διαδραστικά πρωτόκολλα στα οποία συμμετέχουν δύο ή περισσότεροι συμμετέχοντες, οι οποίοι διαθέτουν καμία, μία ή περισσότερες ιδιωτικές εισόδους. Η συνάρτηση που πρέπει να αποτιμηθεί για τις εισόδους αυτές, πρέπει να είναι από πριν γνωστή στους συμμετέχοντες ώστε σε πρωτόκολλα που το υποστηρίζουν να μπορούν να επαληθεύσουν αν αυτή που πρόκειται να αποτιμηθεί είναι η προσυμφωνηθήσα συνάρτηση. Σχετικά με την ασφάλεια του Υπολογισμού Πολλών Μερών είναι σημαντικό να αναφέρουμε ότι τα πρωτόκολλα SMPC μεριμνούν αποκλειστικά και μόνο για την ασφαλή αποτίμηση του υπολογισμού. Αυτό σημαίνει ότι το αποτέλεσμα της αποτίμησης του υπολογισμού μπορεί να αποκαλύπτει σημαντικές πληροφορίες για την είσοδο κάποιου άλλου συμμετέχον, όπως για παράδειγμα στην περίπτωση μιας πύλης AND με δύο εισόδους όπου ελέγχονται από δύο συμμετέχοντες αντίστοιχα. Ας αναλογιστούμε το παράδειγμα της Ασφάλειας μέσω Προσομοίωσης, η οποία χρησιμοποιείται κατά κόρον στον κλάδο του SMPC. Στην περίπτωση αυτή, ένα πρωτόκολλο SMPC που έχει αποδειχθεί ασφαλές με αυτήν τη μέθοδο μας διασφαλίζει ότι οποιοσδήποτε αντίπαλος που ελέγχει κάποιους διεφθαρμένους συμμετέχοντες που συμμετέχουν στο πρωτόκολλο για την αποτίμηση του υπολογισμού δε μαθαίνει καμία πληροφορία παραπάνω από τη διαδικασία εκτέλεσης του πρωτοκόλλου, σε σχέση με την πληροφορία που θα μάθαινε αν συμμετείχε σε ένα πρωτόκολλο ιδανικού κόσμου. Προφανώς, ο αριθμός των διεφθαρμένων συμμετεχόντων που ελέγχονται από τον αντίπαλο, η υπολογιστική ισχύς του αντιπάλου καθώς και ο τρόπος διαφθοράς των συμμετεχόντων εξαρτάται από το μοντέλο αντιπάλου που έχουμε επιλέξει. Είναι αντιληπτό ότι τη γνώση που θα αποκτούσε ένας αντίπαλος στην περίπτωση μιας πύλης AND θα την αποκτούσε σε οποιοδήποτε, ιδανικό ή μη, πρωτόκολλο αποτίμησης της.

Στην ενότητα αυτή βασικές βιβλιογραφικές πηγές αποτέλεσαν τα βιβλία \cite{10.1561/3300000019} και \cite{cramer2015secure}. Επίσης, χρήσιμες εργασίες εισαγωγής και σύνοψης του κλάδου, αποτελούν οι \cite{cryptoeprint:2020/300} και  \cite{zhao2019secure}. Στην συνέχεια θα αναλύσουμε τα βασικά χαρακτηριστικά με βάση τα οποία μπορούμε να κατηγοριοποιήσουμε τα πρωτόκολλα SMPC.

\section{Κατηγορίες πρωτοκόλλων ως προς το μοντέλο αναπαράσταση του υπολογισμού}

Οποιοδήποτε πρωτόκολλο SMPC, για να εκτελέσει τον υπολογισμό μιας συνάρτησης $f$, χρειάζεται να λάβει την συνάρτηση σε μια συγκεκριμένη μορφή που εξαρτάται από το τύπο του πρωτοκόλλου. Δηλαδή, αν θέλουμε να χρησιμοποιήσουμε το πρωτόκολλο αυτό καλούμαστε να αναπαραστήσουμε την $f$ στο κατάλληλο υπολογιστικό μοντέλο για το οποίο έχει φτιαχτεί το πρωτόκολλο. Αυτό συμβαίνει, με οποιαδήποτε μηχανή υπολογισμού, σε έναν Επεξεργαστή (CPU) ή σε μια Εικονική Μηχανή για παράδειγμα χρειάζεται να αναπαραστήσουμε την $f$ στην κατάλληλη συμβολική γλώσσα ενώ σε μια Μηχανή Turing χρειάζεται να την αναπαραστήσουμε με την κατάλληλη αλγεβρική δομή. Στην περίπτωση των πρωτοκόλλων SMPC οι κύριες κατηγορίες που τα διακρίνουμε ως προς την αναπαράσταση της $f$ είναι οι παρακάτω :

\begin{definition}
\textbf{Κύρια Υπολογιστικά Μοντέλα των SMPC πρωτοκόλλων :}
\begin{itemize}
    \item Αναπαράσταση ως Boolean δίκτυο/κύκλωμα Συνδυαστικής Λογικής
    \item Αναπαράσταση ως Αριθμητικό δίκτυο/κύκλωμα
    \item Πιο σύνθετες αναπαραστάσεις, όπως ως Μηχανή Turing ή RAM (Random Access Machine)
\end{itemize}
\end{definition}

Στα πλαίσια αυτής της εργασίας θα αναφερθούμε μόνο σε πρωτόκολλα που ανήκουν στις πρώτες δύο κατηγορίες. Τα πρωτόκολλα που ανήκουν στην τελευταία κατηγορία αποτελούν ιδιαίτερα ενεργό ερευνητικό κλάδο την τελευταία δεκαετία με αρκετά σημαντικές εργασίες όπως οι \cite{cryptoeprint:2014/082} και \cite{goldwasser2013run}.

Προφανώς, οι παραπάνω κατηγορίες Boolean και Αριθμητικών δίκτυο σχετίζονται μεταξύ τους καθώς μπορούμε εύκολα να χρησιμοποιήσουμε ένα Αριθμητικό δίκτυο για τον υπολογισμό ενός Boolean κυκλώματος. Αν πάρουμε για παράδειγμα μια πύλη AND μπορούμε να τη μετατρέψουμε σε αριθμητική ως εξής :
%
\[
\begin{aligned}
    NAND(x, y)  &= AND(OR(x,y), OR(x,NOT(y)), OR(NOT(x),y)) =\\
                &= OR(x,y) + OR(x,NOT(y)) + OR(NOT(x),y) =\\
                &= x \cdot y + x \cdot NOT(y) + NOT(x) \cdot y =\\
                &= x \cdot y + x \cdot (1-y) + (1-x) \cdot y
\end{aligned}
\]
%
Στην συγκεκριμένη μαθηματική έκφραση κάνουμε διαχωρισμό μεταξύ των λογικών πυλών τις οποίες σημειώνουμε με τα ονόματα τους και των συμβόλων τις πρόσθεσης, της αφαίρεσης και του πολλαπλασιασμού οι οποίες αναφέρονται στο μαθηματικό δακτύλιο ή πεδίο στο οποίο ανήκουν τα στοιχεία $x,y$.

Σε αυτό το σημείο πρέπει να αναφερθεί πως ορισμένα πρωτόκολλα SMPC υποστηρίζουν μόνο πεπερασμένο υπολογισμό, δηλαδή πεπερασμένους σε χρόνο αλγορίθμους, και άρα δεν μπορεί να περιέχει άπειρους βρόγχους. Δηλαδή, απαιτείται να γίνει Ξετύλιγμα των βρόγχων (Loop unrolling) στην περίπτωση που υπάρχουν. Αυτό συνήθως συμβαίνει σε πρωτόκολλα στα οποία το κύκλωμα πρέπει να αρχικοποιηθεί (bootstrap) ολόκληρο πριν ξεκινήσει ο υπολογισμός. Στα πρωτόκολλα που θα εξετάσουμε δε συμβαίνει αυτό στην περίπτωση της ασφάλειας ενάντια σε παθητικούς αντιπάλους. Ωστόσο, είμαστε αντιμέτωποι με το εμπόδιο αυτό αν επιθυμήσουμε να μετατρέψουμε τα πρωτόκολλα αυτά σε ασφαλή ενάντια σε ενεργητικούς αντιπάλους μέσω κάποιων ειδικών τεχνικών που θα εξετάσουμε στη συνέχεια του κεφαλαίου.

\section{Κατηγορίες πρωτοκόλλων ως προς τις ιδιότητες ασφάλειας}

Όπως προαναφέραμε, το μοντέλο αναπαράστασης του υπολογισμού που χρησιμοποιεί ένα πρωτόκολλο είναι σύμφυτο με αυτό. Ένα ακόμα σύμφυτο χαρακτηριστικό ενός πρωτοκόλλου είναι η ασφάλεια του. Γενικότερα στα πρωτόκολλα SMPC διακρίνουμε τις παρακάτω κατηγορίες ασφάλειας πρωτοκόλλων :

\begin{itemize}
    \item Πρωτόκολλα ασφαλή ενάντια σε Παθητικούς Αντιπάλους
        \begin{itemize}
            \item Ασφαλή ενάντια σε διεφθαρμένη μειοψηφία
            \item Ασφαλή ενάντια σε διεφθαρμένη πλειοψηφία
        \end{itemize}
    \item Πρωτόκολλα ασφαλή ενάντια σε Ενεργητικούς Αντιπάλους
        \begin{itemize}
            \item Ασφαλή ενάντια σε διεφθαρμένη μειοψηφία
            \item Ασφαλή ενάντια σε διεφθαρμένη πλειοψηφία
        \end{itemize}
\end{itemize}

Προφανώς ένα πρωτόκολλο που είναι ασφαλές ενάντια σε ενεργητικούς αντιπάλους είναι ασφαλές και ενάντια σε παθητικούς. Το ίδιο ισχύει και στην περίπτωση της μειοψηφίας και πλειοψηφίας των διεφθαρμένων συμμετεχόντων. Στο Σχήμα \ref{fig:mp-sdpz-protocols} παραθέτουμε των πίνακα υποστηριζόμενων πρωτοκόλλων και των μοντέλων ασφάλειας στα οποία είναι ασφαλή, της βιβλιοθήκης MP-SPDZ \cite{mp-spdz}. Η βιβλιοθήκη αυτή έχει ίσως την εκτενέστερη υποστήριξη πρωτοκόλλων στην βιβλιογραφία.

\begin{table}[h!]
    \centering
    \resizebox{\columnwidth}{!}{
        \begin{tabular}{|c|l|ll|ll|}
            \hline
            \multicolumn{1}{|l|}{}       &                                                                      & \multicolumn{2}{c|}{Αριθμητικό δίκτυο}                                    & \multicolumn{2}{c|}{Boolean κύκλωμα}                                 \\ \hline
            \multicolumn{1}{|l|}{}       & \diagbox{Μοντέλο Ασφάλειας}{Υπολογιστικό Μοντέλο} & \multicolumn{1}{l|}{$modp$ ή $GF(2^n)$}          & $mod2^n$               & \multicolumn{1}{l|}{Δυαδική Διαμοίραση Μυστικών} & Μπερδεμένα Δίκτυα \\ \hline
            \multirow{}{}{Ενεργητικός}   & Διεφθαρμένη Πλειοψηφία                                               & \multicolumn{1}{l|}{MASCOT / LowGear / HighGear} & SPDZ2k                 & \multicolumn{1}{l|}{Tiny / Tinier}               & BMR               \\ \cline{2-6}
            & Εμπιστή Πλειοψηφία                                                   & \multicolumn{1}{l|}{Shamir / Rep3 / PS / SY}     & Brain / Rep3 / PS / SY & \multicolumn{1}{l|}{Rep3 / CCD / PS}             & BMR               \\ \cline{2-6}
            & Έμπιστη Υπερ-πλειοψηφία                                              & \multicolumn{1}{l|}{Rep4}                        & Rep4                   & \multicolumn{1}{l|}{Rep4}                        & N/A               \\ \hline
            Συγκαλλημένος                       & Διεφθαρμένη Πλειοψηφία                                               & \multicolumn{1}{l|}{CowGear / ChaiGear}          & N/A                    & \multicolumn{1}{l|}{N/A}                         & N/A               \\ \hline
            \multirow{}{}{Παθητικός} & Διεφθαρμένη Πλειοψηφία                                               & \multicolumn{1}{l|}{Semi / Hemi / Temi / Soho}   & Semi2k                 & \multicolumn{1}{l|}{SemiBin}                     & Yao's GC / BMR    \\ \cline{2-6}
            & Έμπιστη Πλειοψηφία                                                   & \multicolumn{1}{l|}{Shamir / ATLAS / Rep3}       & Rep3                   & \multicolumn{1}{l|}{Rep3 / CCD}                  & BMR               \\ \cline{2-6}
            & Dealer                                                               & \multicolumn{1}{l|}{Dealer}                      & Dealer                 & \multicolumn{1}{l|}{Dealer}                      & N/A               \\ \hline
        \end{tabular}
    }
    \caption{Πίνακας υποστηριζόμενων πρωτοκόλλων της βιβλιοθήκης MP-SPDZ \cite{mp-spdz}. Ο παρόν είναι εμπνευσμένος από έναν παρόμοιο, αλλά δυσανάγνωστο, πίνακα που υπάρχει στα εγχειρίδια χρήσης της.}
    \label{fig:mp-sdpz-protocols}
\end{table}

\section{Ασφαλής Υπολογισμός Πολλών Μερών ενάντια σε Παθητικούς Αντιπάλους}

Στη ενότητα αυτή θα εξετάσουμε τρία πρωτόκολλα ιστορικής σημασίας τα οποία χρησιμοποιούνται μέχρι και σήμερα λόγω της ευκολίας υλοποίησης τους και της απόδοσης τους. Τα πρωτόκολλα αυτά είναι τα Μπερδεμένα Δίκτυα Yao, το BMR και το GMW.

\subsection{Πρωτόκολλο Μπερδεμένων Δικτύων Yao (Yao's Garbled Circuits Protocol)}

Το πρωτόκολλο αυτό όπως αναφέραμε και στην Ενότητα \ref{chapter:intro} προτάθηκε από τον Yao το 1986 στις εργασίες \cite{4568207} \cite{4568388}. Πιο συγκεκριμένα, προτάθηκε ως πρωτόκολλο επίλυσης του Προβλήματος των Εκατομμυριούχων, δηλαδή για την περίπτωση των δύο συμμετεχόντων (2PC) αλλά μπορεί να γενικευθεί και σε περισσότερους συμμετέχοντες (MPC). Το συγκεκριμένο πρωτόκολλο απαιτεί την μετατροπή του αλγορίθμου σε μια Boolean συνάρτηση ή αντίστοιχα σε ένα Boolean κύκλωμα Συνδυαστικής Λογικής. Παρακάτω, θα αναλύσουμε την περίπτωση των δύο συμμετεχόντων για μια αυθαίρετη Boolean συνάρτηση και μετά θα αναφερθούμε στο πως μπορεί να επιταχυνθεί ο υπολογισμός με τη χρήση Boolean δικτύου και πως μπορεί να γενικευθεί το πρωτόκολλο για περισσότερους από έναν συμμετέχοντες. Το πρωτόκολλο αυτό είναι ασφαλές απέναντι σε Παθητικούς Αντιπάλους.

\subsubsection{Υπολογισμός με χρήση του Πίνακα Αναζήτησης της συνάρτησης $f$}

Έστω δύο συμμετέχοντες $P_1$ και $P_2$ που θέλουν να εκτελέσουν μια Boolean συνάρτηση $(\mathbf{out}) = f(\mathbf{x}, \mathbf{y})$ με $x$ και $y$ τα διανύσματα των εισόδων των $P_1$ και $P_2$ αντίστοιχα. Έστω επίσης $x_i^j$, το $i$-οστο bit του διανύσματος $x$ για την τιμή $j$ του bit αυτού.  Γνωρίζουμε πως μια Boolean συνάρτηση μπορεί να περιγραφεί πλήρως από τον Πίνακα Αναζήτησης της (Look-up table). Το πρωτόκολλο αυτό απαιτεί κάποιον συμμετέχον να κάνει την προετοιμασία (bootstraping) ο οποίος πρέπει να γνωρίζει τον πλήρη Πίνακα Αναζήτησης της συνάρτησης $f$, ας υποθέσουμε ότι ο $P_1$ εκτελεί αυτή τη διαδικασία. Για κάθε γραμμή του πίνακα ο $P_1$ κρυπτογραφεί την αντίστοιχη έξοδο της συνάρτησης με $2 \cdot (\abs{\mathbf{x}} + \abs{\mathbf{y}})$ διαφορετικά και ομοιόμορφα τυχαία επιλεγμένα κλειδιά χρησιμοποιώντας ένα συμμετρικό κρυπτογραφικό σχήμα με τον εξής τρόπο. Σε κάθε bit εισόδου του πίνακα αντιστοιχεί και ένα ζεύγος κλειδιών, ένα για κάθε τιμή που μπορεί να πάρει, αυτά τα συμβολίζουμε ως $k_{x_i^j}$. Δηλαδή αν $\abs{x}=2$ και $\abs{y}=3$ τότε η έξοδος $\mathbf{out}$ για την ανάθεση τιμών $x=01$ και $y=101$ θα κρυπτογραφηθεί ως $Enc_{k_{x_1^0}, k_{x_0^1}, k_{y_2^1}, k_{y_1^0}, k_{y_0^1}}(\mathbf{out})$. Ένα παράδειγμα της μορφής του πίνακα αυτού βρίσκεται στο Σχήμα \ref{fig:yaos-truth-table}. Ο $P_1$ αφού έχει ολοκληρώσει τη δημιουργία του κρυπτογραφημένου πίνακα αληθείας, εφαρμόζει ομοιόμορφα τυχαίες μεταθέσεις στις γραμμές του και τον αποστέλλει ολόκληρο στον $P_2$. Οι τυχαίες μεταθέσεις εφαρμόζονται στον πίνακα διότι αν ήταν γνωστή η διάταξη των γραμμών του από τον $P_2$ τότε αυτός αφού θα λάμβανε τα κατάλληλα κλειδία που αντιστοιχούν στην ιδιωτική του είσοδο θα μπορούσε βλέποντας την γραμμή που αντιστοιχεί στα κλειδιά που έχει λάβει να καταλάβει ποια είναι η είσοδος του $P_1$. Ωστόσο η μετάθεση των γραμμών δημιουργεί ένα άλλο πρόβλημα. Ο $P_2$ θα πρέπει να προσπαθήσει να αποκρυπτογραφήσει κάθε γραμμή του πίνακα προκειμένου να βρει την σωστή στη χειρότερη περίπτωση ενώ κατά μέσο όρο θα πρέπει να προσπαθήσει να αποκρυπτογραφήσει τις μισές γραμμές του πίνακα. Μια γνωστή αποδοτική τεχνική επίλυσης του προβλήματος αυτού ονομάζεται Point-and-Permute \improvement{Add reference}, στην οποία θεωρούμε το τελευταίο bit του κάθε κλειδιού ως ένα από τα bit του δείκτη που δείχνει που θα τοποθετηθεί η γραμμή αυτή κατά την μετάθεση. Δηλαδή αν στο παραπάνω παράδειγμα τα τελευταία bit των κλειδιών έχουν τις εξής τιμές :
%
\begin{align*}
    \text{Τελευταίο bit κλειδιού : }k_{x_1^0} = 1, k_{x_0^1} = 0, k_{y_2^1} = 1, k_{y_1^0} = 1, k_{y_0^1} = 0
\end{align*}
%
Τότε η γραμμή αυτή θα αποθηκευτεί στην θέση $10110=22$ του πίνακα. Εφόσον έχουμε υποθέσει ότι τα κλειδιά είναι τυχαία επιλεγμένα η μέθοδος αυτή δεν επιρεάζει την ασφάλεια του πρωτοκόλλου. Ο $P_1$ αποστέλλει επίσης μαζί τα κατάλληλα κλειδιά κρυπτογράφησης $k_{x_i^j}$ για τις τιμές του διανύσματος εισόδου $\mathbf{x}$ που έχει επιλέξει. Δηλαδή στο προηγούμενο παράδειγμα θα στείλει τα κλειδιά $k_{x_1^0}$, $k_{x_0^1}$. Στην συνέχεια αποστέλλει στον $P_2$ τα κλειδιά που αντιστοιχούν στις τιμές του διανύσματος εισόδου $\mathbf{y}$, μέσω $|y|-(2 \cdot |y|)$ Ανυποψίαστης Μεταφοράς. Τέλος ο $P_2$ αφού έχει αποκτήσει όλα τα απαραίτητα κλειδιά για την αποκρυπτογράφηση της γραμμής του Πίνακα Αναζήτησης της $f$ που αντιστοιχεί στο $f(\mathbf{x}, \mathbf{y})$, την αποκρυπτογραφεί, βλέπει το αποτέλεσμα $\mathbf{out}$ και στην συνέχεια το στέλνει στον $P_1$.

\begin{figure}
    \centering
\[
    \begin{pmatrix}
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^0}, k_{y_0^0}}(f(\mathbf{x}=00, \mathbf{y}=000))\\
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^0}, k_{y_0^1}}(f(\mathbf{x}=00, \mathbf{y}=001))\\
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^1}, k_{y_0^0}}(f(\mathbf{x}=00, \mathbf{y}=010))\\
        Enc_{k_{x_1^0}, k_{x_0^0}, k_{y_2^0}, k_{y_1^1}, k_{y_0^1}}(f(\mathbf{x}=00, \mathbf{y}=011))\\
        \vdots\\
        Enc_{k_{x_1^1}, k_{x_0^1}, k_{y_2^1}, k_{y_1^1}, k_{y_0^0}}(f(\mathbf{x}=11, \mathbf{y}=110))\\
        Enc_{k_{x_1^1}, k_{x_0^1}, k_{y_2^1}, k_{y_1^1}, k_{y_0^1}}(f(\mathbf{x}=11, \mathbf{y}=111))\\
    \end{pmatrix}
    \caption{Παράδειγμα της διαδικασίας κρυπτογράφησης ενός Πίνακα Αληθείας με το Πρωτόκολλο Μπερδεμένων Δικτύων Yao.}
    \label{fig:yaos-truth-table}
\]
\end{figure}

\subsubsection{Υπολογισμός με χρήση του Boolean Δικτύου της $f$}

Είναι προφανές ότι η παραπάνω μέθοδος δεν μπορεί να κλιμακωθεί σωστά αφού το μέγεθος του Πίνακα Αναζήτησης της $f$ αυξάνεται εκθετικά με το μέγεθος των εισόδων. Μια ιδέα για την επιτάχυνση του υπολογισμού της $f$ από ένα Μπερδεμένο Δίκτυο Yao είναι να την εκφράσουμε ως ένα Boolean Δίκτυο, από την προσέγγιση αυτή προκύπτει ουσιαστικά και το όνομα αυτού του πρωτοκόλλου. Παρακάτω θα επανεξετάσουμε την αποτίμηση μιας συνάρτησης $f$ από τους δύο συμμετέχοντες $P_1$, $P_2$.

Ο $P_1$ όπως και προηγουμένως είναι αυτός που αναλαμβάνει να αρχικοποιήσει το πρωτόκολλο. Στην προκείμενη περίπτωση να κατασκευάσει το Μπερδεμένο Κύκλωμα. Για να το επιτύχει αυτό, αρχικά διατάσσει τοπολογικά το Boolean κύκλωμα. Στην συνέχεια, δημιουργεί ένα ζεύγος κλειδιών για κάθε καλώδιο του κυκλώματος. Διατρέχοντας το με τη τοπολογική του σειρά

\begin{figure}
\centering
\begin{circuitikz}
\draw
  (0,0) node[and port](myand){}
  (myand.in 1) node[left]{$w_i$}
  (myand.in 2) node[left]{$w_j$}
  (myand.out) node[right]{$w_k$};
\end{circuitikz}
\caption{}
\end{figure}

\subsection{Πρωτόκολλο Ben-Or, Goldwasser, Wigderson (BGW Protocol)}

Το πρωτόκολλο αυτό προτάθηκε από τους Ben-Or, Goldwasser, Wigderson στην εργασία \cite{BenOr1988CompletenessTF}. Απαιτεί την μοντελοποίηση της $f$ ως ένα Αριθμητικό Δίκτυο σε ένα πεπερασμένο πεδίο $\mathbf{F}$. Στην αρχική του μορφή βασίζεται στη Διαμοίραση Μυστικών Shamir και πιο συγκεκριμένα στις ομομορφικές ιδιότητες που παρουσιάζουν οι μετοχές του (για περισσότερες πληροφορίες σχετικά με τις ομομορφικές ιδιότητες μπορείτε να ανατρέξετε στο Παράρτημα \improvement{Add reference}), ωστόσο μπορούν να χρησιμοποιηθούν και άλλες μέθοδοι διαμοίρασης μυστικών υπό την προϋπόθεση ότι παρουσιάζουν τις ίδιες ομομορφικές ιδιότητες. Όπως αναλύθηκε στο παράρτημα, το SSS είναι προσθετικά ομομορφικό από μόνο του, οπότε κύρια καινοτομία του πρωτοκόλλου BGW είναι η μετατροπή του SSS ώστε να μπορεί είναι και πολλαπλασιαστικά ομομορφικό. Παρακάτω θα εξετάσουμε τις περιπτώσεις της ομομορφικής πρόσθεσης και πολλαπλασιαμού στην περίπτωση της μιας αριθμητικής πύλης, στην εξετάσουμε πως μπορούμε να γενικέυσουμε το πρωτόκολλο στην περίπτωση των περισσότερον πυλών και τέλος θα παρουσιάσουμε αναλυτικά το πρωτόκολλο.

Έστω ότι $n$ συμμετέχοντες όπου θέλουν να αποτιμήσουν μια αριθμητική συνάρτηση ή αντίστοιχα ένα αριθμητικό δίκτυο $(\mathbf{out}) = f(\mathbf{x}, \mathbf{y})$, όπου $x$, $y$ είναι οι είσοδοι της συνάρτησης και η καθεμία ελέγχεται από κάποιον συμμετέχον. Η αριθμητική συνάρτηση $f$ πρέπει να είναι γνωστή σε όλους τους συμμετέχοντες. Επίσης, ο κάθε συμμετέχον διαθέτει ένα σημείο $i \in \mathbf{F}$ το οποίο το γνωρίζουν όλοι οι συμμετέχοντες στο δίκτυο, για χάριν απλότητας ας υποθέσουμε ότι το $i$ είναι ο αύξων αριθμός του συμμετέχοντος και $i = 0, \ldots, n-1 \in \mathbf{F}$. Στην επόμενη παράγραφο ο συμβολισμός $i$ θα χρησιμοποιείται για να αναφερθούμε είτε στο σημείο του παίχτη $i$ είτε στον ίδιο τον παίχτη $i$.

Στην αρχή του πρωτοκόλλου οι δύο συμμετέχοντες που ελέγχουν αυτές τις δύο εισόδους $x$ και $y$ διαμοιράζουν μέσω $SSS(n,t)$, υπό τον περιορισμό ότι $t < 2n$ (θα αιτιολογηθεί στην συνέχεια ο περιορισμός αυτός), αντίστοιχες μετοχές $[x]_i$ και $[y_i]$ σε κάθε συμμετέχον $i \in 0, 1, \ldots n$. Όπως γνωρίζουμε από το $SSS$, η μετοχή του παίχτη $i$ είναι ένα σημείο $(i, p_x(i))$, για την είσοδο $x$ και το $p_x$ είναι το πολυώνυμο $t$-οστού βαθμού που επέλεξε ο συμμετέχον που ελέγχει την είσοδο $x$ κατά το $SSS$.

\improvement{Replace 2t with 2t+1}

\begin{itemize}
    \item \textbf{Πρόσθεση} : Κάθε συμμετέχον $i$ διαθέτει μια μετοχή $[x]_i$ και μια $[y]_i$ αντίστοιχα. Κάθε συμμετέχον μπορεί να εκτελέσει την πράξη $x+y$, απλώς αθροίζοντας τις τετμημένες των αντίστοιχων μετοχών, δηλαδή $[c]_i = [x]_i + [y]_i$. Το παραπάνω προκύπτει από την ιδιότητα της γραμμικότητας του $SSS$ που αναλύθηκε στην Ενότητα \improvement{Add reference}, αφού προκύπτει ότι $[c]_i = [x]_i + [y]_i = p_x(i) + p_y(i) = p_{x+y}(i) = [x + y]_i$. Η πράξη της πρόσθεσης δεν απαιτεί καμία αλληλεπίδραση μεταξύ των συμμετεχόντων εφόσον ο καθένας τους διαθέτει τις μετοχές $[x]_i$ και $[y]_i$.
    \item \textbf{Πολλαπλασιασμός} :  
        \begin{itemize}
            \item \textbf{Βαθμωτός πολλαπλασιασμός} : Παρόμοια με την πράξη της πρόσθεσης από την γραμμική ιδιότητα του $SSS$ προκύπτει ότι $[c]_i = b \cdot [x]_i = b \cdot p_x(i) = p_{b \cdot x}(i) = [b \cdot x_i ]$.
            \item \textbf{Πολλαπλασιασμός με μεταβλητή εισόδου} : Κάθε συμμετέχον $i$ διαθέτει μια μετοχή $[x]_i$ και μια $[y]_i$ αντίστοιχα. Όπως και με τους υπόλοιπους τελεστές αρχικά ο κάθε συμμετέχον υπολογίζει την μετοχή $[c]_i = [x]_i \cdot [y]_i$. Γνωρίζουμε όμως ότι $[c]_i = [x]_i \cdot [y]_i = p_x(i) \cdot p_y(i) = p_{x \cdot y}(i) (= p_c(i))= [x \cdot y]_i$. Όπως παρατηρούμε το πρόβλημα που προκύπτει στην πράξη του πολλαπλασιασμό είναι ότι ο πολλαπλασιασμός δύο πολυωνύμων $t$-οστού βαθμού, όπως στην προκείμενη περίπτωση των $p_x$ και $p_y$, μπορεί να μας δώσει ως αποτέλεσμα ένα πολυώνυμο μέχρι και $2t$-οστού βαθμού. Είναι απαραίτητο να κρατήσουμε σταθερό αυτό το κατώφλι $t$. Για να το επιτύχουμε αυτό αρχικά ο κάθε συμμετέχον εκτελεί τον πολλαπλασιασμό των μετοχών $[c]_i = [x]_i \cdot [y]_i$, όπως και με τους υπόλοιπους τελεστές. Στο σημείο αυτό το $[c]_i$ έχει κατώφλι διαμοίρασης $2t$. Για να μειωθεί το κατώφλι σε $t$ ο κάθε συμμετέχον $i$ διαμοιράζει το $[c]_i$ με $SSS(n, t)$, ας υποθέσουμε ότι χρησιμοποιεί για αυτό ένα τυχαίο πολυώνυμο $p_{h_i}(x)$ όπου προφανώς $p_{h_i}(0)=[c]_i=p_c(i)$, και στην συνέχεια διαμοιράζει τις μετοχές που αντιστοιχούν στον καθένα από τους υπόλοιπους $n-1$ συμμετέχοντες. Δηλαδή, στον παίχτη $j$ ο παίχτης $i$ θα στείλει την τιμή $p_{h_i}(j)$. Έτσι, ο κάθε συμμετέχον $j$ διαθέτει τις μετοχές $p_{h_i}(j)$ για κάθε $i \in 1, 2, \ldots n$. Στην συνέχεια κάθε συμμετέχον υπολογίζει την τελική του μετοχή ως εξής :
            
            \begin{equation}\label{eq:bgw1}
            h(j) = \sum_{i=1}^{2t+1}λ_i(x)h_i(j)
            \end{equation}
            
            όπου $λ_i$ είναι ο κατάλληλος συντελεστής που αναφέρεται στο παράρτημα \improvement{Add reference} και μπορεί να υπολογιστεί από κάθε συμμετέχοντα αφού είναι δημόσια γνωστό στους συμμετέχοντες ότι $α_i=i$. Επειδή, η ορθότητα της Σχέσης \ref{eq:bgw1} ίσως να μην είναι προφανής ας σταθούμε λίγο περισσότερο σε αυτήν. Η Σχέση \ref{eq:bgw1} μπορεί να αναπτυχθεί στην παρακάτω :
            $$            
                 p_h(j) = \sum_{i=1}^{2t+1}λ_i(x)p_{h_i}(j) = λ_1p_{h_1}(j) + λ_2p_{h_2}(j) + \ldots + λ_n p_{h_n}(j)
            $$
            και ουσιαστικά το πολυώνυμο $p_h(x)$ του οποίου σημείο είναι το $p_h(j)$ είναι το παρακάτω : 
            $$
                p_h(x) = λ_1p_{h_1}(x) + λ_2p_{h_2}(x) + \ldots + λ_n p_{h_n}(x)
            $$
            και ισχύει ότι $deg(p_h(x))=t$ αφού είναι άθροισμα των πολυωνύμων $p_{h_i}$ για καθένα από τα οποία ισχύει $deg(p_{h_i} = t)$. Επίσης, μπορούμε να επαληθεύσουμε ότι $h(0)=p_c(0)$ αφού
            
            \begin{align}
                p_h(0) &= λ_1 p_{h_1}(0) + λ_2 p_{h_2}(0) + \ldots + λ_n p_{h_n}(0) \\
                &= λ_1 p_c(1) + λ_2 p_c(2) + \ldots + λ_n p_c(n) \\
                &= p_c(0)
            \end{align}

        \end{itemize}
\end{itemize}

Το παραπάνω πρωτόκολλο μπορεί να παραλαχθεί ώστε να είναι ασφαλές ενάντια σε Ενεργητικούς αντιπάλους, όπως για παράδειγμα στις εργασίες \improvement{add reference}, ωστόσο δεν θα αναφερθούμε σε αυτά τα πρωτόκολλα στα πλαίσια αυτής της εργασίας, λόγω της πολυπλοκότητας τους.

\subsubsection{Επιτάχυνση του πρωτοκόλλου με χρήση Πολλαπλασιαστικών Τριάδων Beaver (Beaver Triples)}
Στο πρωτόκολλο BGW, στην περίπτωση του πολλαπλασιασμού που έχει προκύψει από είσοδο, κάθε παίχτης πρέπει να εκτελέσει $SSS(n,t)$ και δηλαδή να διαμοιράσει $n$ μετοχές. Αυτό έχει πολυπλοκότητα επικοινωνίας $O(n^2)$. Μπορούμε να βελτιώσουμε την παραπάνω πολυπλοκότητα επικοινωνίας αν χωρίσουμε τον υπολογισμό σε δύο φάσεις, την \textbf{Φάση προεπεξεργασίας (Preprocessing phase)} και την \textbf{Online φάση}. Έτσι μπορούμε να επιτύχουμε βελτίωση της πολυπλοκότητας επικοινωνίας με τον εξής τρόπο.

Ας υποθέσουμε ότι $x$ και $y$ είναι οι είσοδοι της πολλαπλασιαστικής πύλης για τις οποίες κάθε συμμετέχον διαθέτει μετοχές $[x]$ και $[y]$ αντίστοιχα. Επίσης έστω οι τιμές $a, b \sample \mathbb{F_p}$, $c=a \cdot b$ και οι αντίστοιχες μετοχές $[a]$, $[b]$, $[c]$ τους. Τότε ο κάθε συμμετέχον μπορεί να υπολογίσει την πολλαπλασιαστική πύλη ακολουθώντας τα παρακάτω βήματα :

\begin{enumerate}
    \item Υπολόγιζει τα $[x - a]$ και $[y - b]$ και ανακοινώνει δημόσια τις τιμές $d = x - a$ και $e = y - b$.
    \item Υπολογίζει το $de + d[b] + e[a] + [c] = [x \cdot y]$ αφού,
    \begin{align}
        xy &= (x - a + a)(y - a + a) \\
           &= (d + a)(d + b) \\
           &= de + db + ae + ab \\
           &= de + db + ae + c
    \end{align}
\end{enumerate}

Τέλος, να σημειώσουμε ότι ο διαχωρισμός του πρωτοκόλλου σε περισσότερες από μία φάσεις είναι κάτι πολύ σύνηθες στην περίπτωση των SMPC και FHE πρωτοκόλλων, που αποσκοπεί συνήθως στην εξοικονόμηση  χρονικής ή χωρικής πολυπλοκότητας κάθε φάσης μέσω των προηγούμενων της.

\subsection{Πρωτόκολλο Goldreich, Micali, Wigderson (GMW Protocol)}

Το πρωτόκολλο αυτό προτάθηκε από τους Goldwasser, Micali, Wigderson στην εργασία \cite{goldreich2019play} το 1987. Μπορεί να χρησιμοποιηθεί για την αποτίμηση συναρτήσεων μοντελοποιημένων ως Boolean δίκτυα αλλά και ως αριθμητικά δίκτυα ωστόσο θα επικεντρωθούμε στις Boolean συναρτήσεις. Το πρωτόκολλο αυτό μοιάζει σε ένα βαθμό, με αυτό του Yao, που περιγράψαμε προηγουμένως. Οι συμμετέχοντες έχουν ένα Boolean δίκτυο το οποίο αποτιμούν πύλη με πύλη (gate-by-gate) με τοπολογική σειρά. Ένα ακόμα κοινό χαρακτηριστικό είναι ότι και το GMW χρησιμοποιεί OT για τον υπολογισμό ορισμένων Boolean πυλών. Σε αυτό το χαρακτηριστικό βασίζεται και η κύρια διαφορά των δύο πρωτοκόλλων. Το GMW απαιτεί ΟΤ μόνο στην περίπτωση της AND πύλης, ενώ οι πύλες NOT και XOR μπορούν να υπολογιστούν χωρίς OT. Το γεγονός αυτό κάνει το GMW κατά μέσο όρο πιο γρήγορο από τo πρωτόκολλο του Yao.

Στο πρωτόκολλο αυτό για κάθε καλώδιο του Boolean δικτύου δημιουργούνται δύο μετοχές και ο κάθε συμμετέχον κρατάει μια από αυτές.

\begin{itemize}
    \item \textbf{Πύλη NOT} : Στην περίπτωση της Πύλης NOT, ένας από τους δύο συμμετέχοντες (όχι και οι δύο), το μόνο που έχει να κάνει είναι να αντιστρέψει το bit της μετοχής του.
    \item \textbf{Πύλη XOR} : Στην περίπτωση της Πύλης XOR, οι δύο συμμετέχοντες κάνουν XOR τις μετοχές που έχουν για κάθε μία από τις δύο εισόδους της πύλης.
%    \item \textbf{Πύλη AND}
        Στην περίπτωση της πύλης
\end{itemize}

\begin{figure}
    \centering
    \begin{circuitikz}
        \draw
        (0,0) node[ieeestd and port](myand){}
        (myand.in 1) node[left]{$s_i^0, s_i^1$}
        (myand.in 2) node[left]{$s_j^0, s_i^1$}
        (myand.out) node[right]{$w_k^0, w_k^1$};
    \end{circuitikz}
    \caption{}
\end{figure}

\section{Ασφαλής Υπολογισμός Πολλών Μερών ενάντια σε Ενεργητικούς Αντιπάλους}

\subsection{Τεχνικές Μετατροπής μετατροπής της ασφάλειας πρωτοκόλλων από Παθητική σε Ενεργητική}

\subsubsection{Τεχνικές Cut-and-Choose}

\subsection{Πρωτόκολλα Ασφαλή ενάντια σε Ενεργητικούς Αντιπάλους}

\subsection{SPDZ}