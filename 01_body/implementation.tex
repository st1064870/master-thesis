\chapter{Υλοποίηση}
\label{chapter:implementation}

Στο κεφάλαιο αυτό θα περιγράψουμε την πειραματική υλοποίηση που πραγματοποιήθηκε στα πλαίσια αυτής της διπλωματικής εργασίας. Πρόκειται για την υλοποίηση Βασικών Υπορουτινών Γραμμικής Άλγεβρας (Basic Linear Algebra Subroutines ή BLAS) Επιπέδου 1 για Ασφαλή Υπολογισμό Δύο Μερών η οποία βασίζεται στην βιβλιοθήκη ABY για την εκτέλεση των πρωταρχικών κρυπτογραφικών και ασφαλούς υπολογισμού διεργασιών. Την βιβλιοθήκη που υλοποιήσαμε ονομάζουμε MPC-BLAS, ωστόσο ένα ίσως καταλληλότερο όνομα θα ήταν το 2PCBLAS. Πρωτού περάσουμε στην ανάλυση της MPC-BLAS βιβλιοθήκης, πρέπει πρώτα να αναλύσουμε  ένα λιγότερο κρυπτογραφικό κομμάτι αυτής της εργασίας, τις απλές BLAS βιβλιοθήκες.

\section{Η διεπαφή BLAS}

Η Γραμμική Άλγεβρα αποτλεί πλέον θεμελιώδες μαθηματικό εργαλείο των θετικών επιστήμων, για αυτό και αποτελεί βασικό μάθημα των πρώτων ετών των προπτυχιακών σπουδών σε σχεδόν όλες τις σχολές θετικών επιστημών. Εξετάζωντας μόνο την επιστήμη της πληροφορικής, την βλέπουμε σε πάρα κλάδους της, όπως την Μηχανική Μάθηση (π.χ. SVM), στην Ψηφιακή Επεξερφασία Σημάτων (π.χ. FFT), στην Αριθμητική Ανάλυση, στην Κρυπτογραφία (π.χ. Κρυπτογραφία Πλεγμάτων), στα Γραφικά Υπολογιστών (π.χ. Ray Tracers) καθώς και σε πολλούς ακόμα.
Η μαζικότητα αυτή, της χρήσης της γραμμικής άλγεβρας, δημιούργησε από τα πρώτα χρόνια των γλωσσών προγραμματισμού την επιτακτική ανάγκη για την εκτέλεση γρήγορων πράξεων γραμμικής άλγεβρας. Έτσι, από τα χρόνια της γλώσσας Fortan, εγκαθιδρύθηκε από το BLAS Technical Foroum ένα πρότυπο, μια διεπαφή συναρτήσεων, την οποία μπορούν να χρησιμοποιούν τα προγράμματα Fortran (Basic Linear Algebra Subroutines ή BLAS). Ο σκοπός της διεπαφής αυτής είναι η υλοποίηση να μπορεί να είναι διαφορετική
από πλατφόρμα σε πλατφόρμα, ώστε να εκμεταλλεύεται τις ιδιομορφίες του υλικού της κάθε πλατφόρμας. Κρατώντας την διεπαφή σταθερή δεν χρειάζεται να αλλάξει ένα πρόγραμμα που την χρησιμοποιεί. Το μόνο που χρειάζεται να γίνει είναι να ξανά μεταγλωττιστεί το πρόγραμμα για την συγκεκριμένη πλατφόρμα και να συνδεθεί (linked) με την νέα BLAS υλοποίηση. Μάλιστα στην περίπτωση που η BLAS υλοποίηση υποστηρίζει δυναμική σύνδεση (dynamic linking) μπορεί να μην είναι απαραίτητο να ξαναμεταγλωττιστεί το πρόγραμμα για την συγκεκριμένη πλατφόρμα. Με την έλευση της γλώσσας C, δημιουργήθηκε αντίστοιχη διεπαφή για την C όπως και με αυτή της Fortran. Έχει επικρατήσει να καλούμε την διεπαφή για την Fortran ως BLAS ενώ για την C ως CBLAS.

Γενικότερα, η ύπαρξη τέτοιου είδους διεπαφής δίνει την δυνατότητα σε κατσκευαστές υλικού, για παράδειγμα επεξεργαστών ή καρτών γραφικών, να δημιουργήσουν BLAS υλοποιήσεις που να εκμεταλλέυονται τα χαρακτηριστικά των κάθε υλικού τους. Έτσι σήμερα υπάρχουν στη βιβλιογραφία πάρα πολλές υλοποιήσεις της διεπαφής BLAS, ανοιχτού ή κλειστού κώδικα, από ποικίλους συγγραφείς, μεταξύ των οποίων και οι μεγαλύτεροι κατασκευαστές υλικού επεξεργαστών και καρτών γραφικών.

Η διεπαφή BLAS, χωρίζεται σε τρία επίπεδα. Το δεύτερο επίπεδο περιέχει πράξεις μόνο μεταξύ διανυσμάτων ή γενικότερα πράξεις επάνω σε διανύσματα, όπως για παράδειγμα η εύρεση της θέσεις του στοιχείου με τη μεγαλύτερη απόλυτη τιμή (πράξη IxAMAX). Το δεύτερο επίπεδο περιέχει μόνο πράξεις μεταξύ πινάκων και διανυσμάτων ενώ το τρίτο επίπεδο περιέχει μόνο πράξεις μεταξύ πινάκων. Στα πλαίσια της εργασίας αυτής θα αναφερθούμε μόνο στις πράξεις του πρώτου επιπέδου οι οποίες φαίνονται συνοπτικά και με αφαιρετικό τρόπο στο Σχήμα \ref{code:blas-level-1}, ολόκληρη η διεπαφή BLAS βρίσκεται στην \improvement{Add reference}. Οι ονομασίες που χρησιμοποιούντε για τις συναρτήσεις και τις υπορουτίνες είναι στη μορφή xDOT. Το x είναι ένας χαρακτήρας μπαλαντέρ που παίρνει τιμές S, D, C, Z ανάλογα με το αν αναφερόμαστε σε πραγματικούς αριθμούς, μονής ή διπλή ακρίβειας, ή σε μιγαδικούς αριθμούς, μονής ή διπλής ακρίβειας, αντίστοιχα. Για παράδειγμα, η αντίστοιχη διεπαφή CBLAS, για την συνάρτηση xDOT, φαίνεται στο Σχήμα \ref{code:cblas-level-1}. Ολόκληρη η διεπαφή CBLAS βρίσκεται στην \improvement{Add reference}.

Στο παράδειγμα του Σχήματος \ref{code:blas-level-1}, ως συναρτήσεις (functions) θεωρούνται αυτές που επιστρέφουν την έξοδο τους ως την επιστρεφόμενη τιμή. Ωστόσο, δεν είναι εμφανές με ποιον τρόπο γίνεται η επιστροφή των εξόδων των υπορουτινών. Αυτή γίνεται με επιστροφή μέσω αναφοράς (return by reference). Έτσι για παράδειγμα η υπορουτίνα xAXPY τοποθετεί την καινούργια τιμή του $Y$ στην διεύθυνση που βρίσκεται η παλιά του τιμή. Οι παραμέτροι $INCx$ που βρίσκονται σε όλες τις συναρτήσεις που παίρνουν ως όρισμα ένα διάνυσμα καθορίζουν το βήμα θα διαβαστούν οι τιμές του διανύσματος. Αν θέλουμε να χρησιμοποιήσουμε ολόκληρο το διάνυσμα $X$ μπορούμε να χρησιμοποιήσουμε $INCX=1$ ενώ αν θέλουμε να διαβάσουμε μόνο τις τιμές που βρίσκονται στις άρτιες θέσεις του μπορούμε να χρησιμοποιήσουμε την τιμή $INCX=2$. Τέλος η τιμή $N$ είναι ο αριθμός των τιμών που θα διαβαστούν από το κάθε διάνυσμα.

\begin{figure}
    \centering
\[
\scalemath{0.6}{
\begin{array}{lllllllllllllllll}
%  & &  & dim & scalar & vector \\
SUBROUTINE & xROTG  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & \text{Generate plane rotation}\\
SUBROUTINE & xROTMG & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & \text{Generate modified plane rotation}\\
SUBROUTINE & xROT   & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & \text{Apply plane rotation}\\
SUBROUTINE & xROTM  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & \text{Apply modified plane rotation}\\
SUBROUTINE & xSWAP  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & x \leftrightarrow y\\
SUBROUTINE & xSCAL  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & x \leftarrow y\\
SUBROUTINE & xCOPY  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & y \leftarrow x\\
SUBROUTINE & xAXPY  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & y \leftarrow ax + y\\
FUNCTION   & xDOT   & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & dot \leftarrow x^Ty\\
FUNCTION   & xDOT   & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & dot \leftarrow x^Ty\\
FUNCTION   & xDOTU  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & dot \leftarrow x^Hy\\
FUNCTION   & xDOTC  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & \dot \leftarrow a + x^Ty\\
FUNCTION   & xxDOT  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) &  dot \leftarrow a + x^Ty\\
FUNCTION   & xNRM2  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & nrm2 \leftarrow \abs{x}_2\\
FUNCTION   & xASUM  & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & asum \leftarrow \abs{re(x)}_1 + \abs{im(x)}_1\\
FUNCTION   & IxAMAX & ( & N, & X, & INCX, & Y, & INCY, & D1, & D2, & A, & B, & C, & S, & PARAM & ) & amax \leftarrow 1^{st}k \abs{re(x_k)} + \abs{im(x)}_1\\
\end{array}
}
\]
    \caption{Πίνακας Βασικών Υπορουτινών Γραμμικής Άλγεβρας - Επιπέδου 1 (BLAS-Level 1)}
    \label{code:blas-level-1}
\end{figure}

\begin{figure}[h]
    \centering
        \inputminted[fontsize=\scriptsize,frame=single]{c}
        {./01_body/code/cblas-level-1.h}
    \caption{Διεπαφή CBLAS Επιπέδου 1.}
    \label{code:cblas-level-1}
\end{figure}

\section{Η βιβλιοθήκη MPC-BLAS}

Στα πλαίσια αυτής της εργασίας υλοποιήθηκε η βιβλιοθήκη MPC-BLAS. Πρόκειται για μια πειραματική βιβλιοθήκη που ο απότερος σκοπός της είναι να μπορέσει να αποτελέσει ένα σχεδόν "drop-in" αντικατάστατο μιας BLAS βιβλιοθήκης. 


\section{Βασικές Υπορουτίνες Γραμμικής Άλγεβρας}

\section{Η βιβλιοθήκη ABY}

Η βιβλιοθήκη ABY είναι η βιβλιοθήκη στην οποία στηρίχθηκε η εφαρμογή μας για την εκτέλεση για την εκτέλεση των πρωταρχικών κρυπτογραφικών και ασφαλούς υπολογισμού διεργασιών. Παρουσιάστηκε στην βιβλιογραφία το 2018 στην εργασία \improvement{Add reference}. Πρόκειται για μια βιβλιοθήκη Ασφαλούς Υπολογισμού Δύο Μερών, που υποστηρίζει πρωτόκολλα που βασίζονται σε Boolean και Αριθμητικά Δίκτυα τα οποία μπορούν να συνδυαστούν σε μια εκτέλεση λόγω της υβριδικής της φύσης. Για την περίπτωση των Boolean δικτύων υποστηρίζονται τα πρωτόκολλα GMW και Yao, ενώ για την περίπτωση των αριθμητικών δικτύων υποστηρίζεται το πρωτόκολλο BGW. Τα τρία αυτά πρωτόκολλα αναλύθηκαν στο Κεφάλαιο \ref{chapter:SMPC}.

\subsection{Εξέταση της καταλληλότητας της βιβλιοθήκης ABY}

Πριν προχωρήσουμε με την ανάλυση της βιβλιοθήκης ας εξετάσουμε τα κριτήρια επιλογής της. Αρχικά, εφόσον θέλουμε να υλοποιήσουμε μια διεπαφή για C (τη CBLAS) είμαστε σχεδόν αναγκασμένοι να χρησιμοποιήσουμε C/C++. Αυτό συνεπάγεται πως η κυριότερη μας απαίτηση για όποιες κρυπτογραφικές βιβλιοθήκες επιθυμούμε να χρησιμοποιήσουμε, είναι να διαθέτουν διεπαφή για C/C++ και να μπορούν να μεταγλωττιστούν ώστε να είναι συνδέσιμες (linkable) από προγράμματα που χρησιμοποιούν τη C/C++. Ακόμα μια απαίτηση είναι ότι επιθυμούμε από τη βιβλιοθήκη που θα χρησιμοποιήσουμε να υποστηρίζει πράξεις με μιγαδικούς αριθμούς μονής και διπλής ακρίβειας. Σαν τελευταία απαίτηση, θα επιθυμούσαμε να έχει και κατάλληλη τεκμηρίωση και παραδείγματα σχετικά με τον πως να τη χρησιμοποιήσουμε. Δυστυχώς, δύο από τις πιο γνωστές βιβλιοθήκες για SMPC, η MP-SPDZ και η SCALE-MAMBA δεν ικανοποιούν την πρώτη και τελευταία απαίτηση. Ένα ακόμα σημαντικό αυτών των δύο βιβλιοθηκών είναι πως αρχικά υποστηρίζουν περισσότερους των δύο συμμετέχοντες και επίσης υποστηρίζουν πρωτόκολλα όπως το SPDZ που είναι ασφαλή ενάντια σε ενεργητικούς αντιπάλους. Χαρακτηριστικά σαν αυτά θα τα επιθυμούσαμε να τα έχει η βιβλιοθήκη μας. Δυστυχώς, όμως στην περίπτωση της MP-SPDZ το οποίο υποστηρίζει διεπαφή σε C/C++ η τεκμηρίωση που διαθέτει για αυτήν είναι μηδαμινή. Η περίπτωση της SCALE-MAMBA δεν υποστηρίζει καθόλου διεπαφή σε C/C++. Αυτό συμβαίνει διότι η βιβλιοθήκη SCALE-MAMBA, βασίζεται στην αρχιτεκτονική της υλοποίησης ενός εικονικού κατανεμημένου επεξεργαστή με δική του συμβολική γλώσσα, της οποίας οι εντολές εκτελούνται πάνω σε πρωτόκολλα SMPC. Από της λίγες βιβλιοθήκες της βιβλιογραφίας που υποστηρίζουν διεπαφή και σύνδεση με C/C++ είναι η ABY. Αυτή ικανοποιεί την πρώτη και τρίτη απαίτηση, ωστόσο έχει το μειονέκτημα πως δεν υποστηρίζει πράξεις με μιγαδικούς αριθμούς και με αριθμούς κινητής υποδιαστολής διπλής ακρίβειας για ορισμένες πράξεις, όπως αυτή της τετραγωνικής ρίζας που χρησιμοποιείται σε κάποιες BLAS συναρτήσεις.

\subsection{Εγκατάσταση χρήση της βιβλιοθήκης ABY}

H ΑΒΥ είναι αρκετά εύχρηστη και αυτό αποτελεί και έναν από τους σημαντικότερους λόγους που την επιλέξαμε. Σε ένα CMAKE project μπορεί να εγκατασταθεί προσθέτοντας τον κώδικα του Σχήματος \ref{code:aby-installation} στην αρχή του αρχείου. Το βήμα αυτό θα κατεβάσει αυτόματα την τελευταία έκδοση της βιβλιοθήκης από το αποθετήριο Github καθώς και απαιτούμενες από την ABY βιβλιοθήκες.

Ας δούμε τώρα ένα παράδειγμα σχετικά με το πως μπορούμε να χρησιμοποιήσουμε την ABY. Η βιβλιοθήκη αυτή διαθέτει τρεις κύριες κλάσεις οι οποίες εμφανίζονται παντού στη χρήση της. Την κλάση ABYParty, η οποία αντιπροσωπεύει μια SMPC οντότητα. Η ABYParty χρησιμοποιείται για την αρχικοποίηση του συστήματος με τις απαραίτητες παραμέτρους, όπως η διεύθυνση και η πόρτα του άλλου μέρους. Εφόσον η ABY υποστηρίζει μόνο Ασφαλή Υπολογισμό 2 Μερών, είναι αντιληπτό πως θα χρειαστούν δύο στιγμιότυπα αυτής της κλάσης. Αυτές οι οντότητες μπορούν να δημιουργούνται είτε από δύο διαφορετικές διεργασίες που προέρχονται από δύο διαφορετικούς πηγαίους κώδικες, είτε από μια διεργασία η οποία εκτελείται με κάποιον τρόπο δύο φορές (είτε χειροκίνητα είτε μέσω κάποιας κλήσης συστήματος fork()). Σε μια διεργασία μπορεί να υπάρχει μόνο ένα στιγμυότυπο της κλάσης ABYParty. Η δεύτερη σημαντική κλάση είναι αυτή του δικτύου, δηλαδή είτε η BooleanCircuit είτε η ArithmeticCircuit. Η κλάση διαθέτει κατάλληλες συναρτήσεις για το χτίσιμο του επιθυμητού δικτύου. Η τρίτη σημαντική κλάση είναι η Sharing. Αυτή δε συνδέεται απαραίτητα με το Shamir Secret Sharing. Στιγμυότυπα αυτής της κλάσης συνήθως δε δημιουργούνται χειροκίνητα αλλά μας επιστρέφονται όταν καλούμε μια συνάρτηση προσθήκης πύλης σε ένα δίκτυο. Ουσιαστικά είναι μια κλάση που κρατάει αναφορές στα καλώδια εξόδου μιας πύλης ώστε να μπορούμε να τα χρησιμοποιήσουμε σαν μια έξοδο σε μια επόμενη πύλη. Η βιβλιοθήκη αυτή είναι κατασκευασμένη με τέτοιο τρόπο ώστε να μπορεί να τρέξει τόσο τοπικά όσο και απομακρυσμένα. Υποθέτοντας ότι θα δημιουργήσουμε μια διεργασία η οποία στη συνέχεια θα καλεί την κλήση συστήματος fork(), η διαδικασία χρήσης έχει ως εξής :

\begin{enumerate}
    \item Δημιουργούμε ένα στιγμιότυπο της κλάσης ABYParty, περνώντας όλες τις απαραίτητες παραμέτρους που χρειάζεται για να γίνει η εκκίνηση της βιβλιοθήκης. Σημαντικό είναι να αναφέρουμε πως η παράμετρος port πρέπει να είναι ίδια ανεξαρτήτως αν εκτελούμε τοπικά ή απομακρυσμένα τη βιβλιοθήκη.
    \begin{figure}[h!]
        \begin{center}
            \inputminted[fontsize=\scriptsize,frame=single]{cpp}{./01_body/code/aby-example-step-1.cpp}
        \end{center}
    \end{figure}
    \item Στην συνέχεια παίρνουμε πρόσβαση στο δίκτυο που επιθυμούμε του ABYParty που δημιουργήσαμε. Τα στιγμιότυπα αυτά των δικτύων τα χρησιμοποιούμε για να προσθέσουμε πύλες στο δίκτυο μας.
    \begin{figure}[h!]
                  \begin{center}
                      \inputminted[fontsize=\scriptsize,frame=single]{cpp}{./01_body/code/aby-example-step-2.cpp}
                  \end{center}
    \end{figure}
    \item Εισάγουμε πύλες εισόδων στο δίκτυο δίνοντας ως ορίσματα σε αυτές τις επιθυμητές εισόδους. Αυτό το επιτυγχάνουμε καλώντας της μεθόδους PutINGate και PutDummyINGate. Η πρώτη χρησιμοποιείται αν ο συμμετέχον θέλει να εισάγει κάποια ιδιωτική είσοδο. Για κάθε ιδιωτική είσοδο που εισάγει κάποιος συμμετέχον ο άλλος συμμετέχον πρέπει να χρησιμοποιήσει τη δεύτερη μέθοδο. Δηλαδή έχουμε ένα ζεύγος κλήσεων των δύο μεθόδων για κάθε ιδιωτική είσοδο που εισάγεται στο κύκλο μα. Οι διαστάσεις των πύλεων IN πρέπει να συμπίπτουν. Συμπληρωματικά να αναφέρουμε πως υπάρχουν επίσης και οι μέθοδοι PutSharedINGate και PutCONSGate, για την είσοδο από κοινού γνωστών τιμών και σταθερών τιμών στο κύκλωμα αντίστοιχα.
    \item Σε αυτό το σημείο όπου οι συμμετέχοντες αφού έχουν εισάγει όλες τις εισόδους τους στο κύκλωμα μπορούν να εισάγουν τις ενδιάμεσες πύλες του κυκλώματος. Τα στιγμιότυπα των δικτύων που αποκτούμε στο Βήμα 2 διαθέτουν μεγάλη ποικιλομορφία πυλών που μπορούν να εισαχθούν.
    \begin{figure}[h!]
        \begin{center}
            \inputminted[fontsize=\scriptsize,frame=single]{cpp}{./01_body/code/aby-example-step-4.cpp}
        \end{center}
    \end{figure}
    \item Αφού έχει χτιστεί ολόκληρο το κύκλωμα το μόνο που απομένει στο χτίσιμο του δικτύου είναι να εισαχθούν πύλες εξόδου. Αυτό επιτυγχάνεται μέσω των μεθόδων PutOUTGate.
    \begin{figure}[h!]
        \begin{center}
            \inputminted[fontsize=\scriptsize,frame=single]{cpp}{./01_body/code/aby-example-step-5.cpp}
        \end{center}
    \end{figure}
    \item Τέλος, το μόνο που απομένει είναι τρέξουμε το δίκτυο ώστε να γίνει η αποτίμηση του και οι συμμετέχοντες να λάβουν τις εξόδους της.
    \begin{figure}[h!]
        \begin{center}
            \inputminted[fontsize=\scriptsize,frame=single]{cpp}{./01_body/code/aby-example-step-6.cpp}
        \end{center}
    \end{figure}
\end{enumerate}

Θα εξετάσουμε τώρα ένα παράδειγμα χρήσης της βιβλιοθήκης ABY.



\begin{figure}[h]
    \centering
    \inputminted[fontsize=\scriptsize,frame=single]{cmake}
    {./01_body/code/ABY.cmake}
    \caption{Παράδειγμα εγκατάστασης της βιβλιοθήκης ABY}
    \label{code:aby-installation}
\end{figure}

\begin{figure}[h]
    \centering
    \inputminted[fontsize=\scriptsize,frame=single]{cpp}
    {./01_body/code/aby-test.cpp}
    \caption{Παράδειγμα προγράμματος με χρήση της βιβλιοθήκης ABY}
    \label{code:aby-example}
\end{figure}

\section{Η βιβλιοθήκη MPCBLAS}

\subsection{Συνοπτική παρουσίαση}

\subsection{Υλοποίηση}

\subsection{Διεπαφή}

\subsection{Χρήση}

\subsubsection{Παράδειγμα χρήσης}














