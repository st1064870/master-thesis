
\begin{definition}
Ως Shannon Cipher ορίζεται το ζεύγος συναρτήσεων $\mathcal{E} = (E,D)$ οι οποίες όρίζονται ως εξής:
\begin{itemize}
    \item $\mathcal{E} : \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{C}$
    \item $\mathcal{D} : \mathcal{K} \times \mathcal{C} \rightarrow \mathcal{M}$
\end{itemize}
όπου $\mathcal{M}$, $\mathcal{C}$, $\mathcal{D}$ είναι οι χώροι των μηνυμάτων, κρυπτοκειμένων και κλειδιών αντίστοιχα.
\end{definition}

 σε ένα κβαντικό κανάλι επικοινωνίας μπορεί να γίνει αντιληπτή η παρουσία τρίτου σε αντίθεση με ένα ασύρματο κανάλι επικοινωνίας.
 
 όπως και με τους υπόλοιπους τελεστές. Ωστόσο, επειδή τον πολλαπλασιασμό των μετοχών το $[c]_i$ ανήκει πλέον σε ένα $SSS(n, 2t)$  ένας γύρος του πρωτοκόλου προκειμένου να μειωθεί το κατόφλι της διαμοίρασης από $2t$ σε $t$. 
 
 % Ας δούμε για παράδειγμα πως ορίζεται το παιχνίδι στην περίπτωση της Σημασιολογικής Ασφάλειας. \todo{}

% \begin{figure}[H]
% \centering
% \fbox{
%     \procedure{\ind-Game} {
%     \textbf{Challenger \cdv} \< \< \textbf{Adversary \adv} \\
%     \< \sendmessageleft*{m_0, m_1 \in M} \< \\
%     b \sample \bin \< \< \\
%     k \sample K \< \< \\
%     c \sample E(k, m_b) \< \< \\
%     \< \sendmessageright*{c} \< \\
%     \< \sendmessageleft*{\hat{b} \in \{0, 1\}}\\
%     }
% }

% \caption{Caption}
% \label{fig:my_label}
% \end{figure}

% Game 0. This is the original attack game, which we can state algorithmically as follows:
% $$
% \begin{aligned}
% &x \leftarrow \mathbb{Z}_{q}, k \leftarrow K, \alpha \leftarrow \gamma^{x} \\
% &r \text { ๕ } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
% &b \Leftarrow\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, \delta \leftarrow \alpha^{y}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
% &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
% \end{aligned}
% $$
% We define $S_{0}$ to be the event that $b=\hat{b}$ in Game 0 .
% Game 1. [This is a transition based on indistinguishability.] Now we transform Game 0 into Game 1, computing $\delta$ as $\gamma^{z}$ for random $z \in \mathcal{Z}_{\text {q }}$. We can state Game 1 algorithmically as follows:
% $x \leftrightarrows \mathbb{Z}_{q}, k \hookleftarrow K, \alpha \leftarrow \gamma^{x}$
% $r \notin R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
% $b \leftrightarrows\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z \leftarrow \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b}$
% $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$
% Let $S_{1}$ be the event that $b=\hat{b}$ in Game 1 . We claim that
% $$
% \left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|=\epsilon_{\mathrm{ddh}}
% $$
% where $\epsilon_{\text {ddh }}$ is the DDH-advantage of some efficient algorithm (which is negligible under the DDH assumption).

% The proof of this is almost identical to the proof of the corresponding claim for "plain" ElGamal. Indeed, the following algorithm $D$ "interpolates" between Game 0 and Game 1 , and so has DDH-advantage equal to $\left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|$ :
% Algorithm $D(\alpha, \beta, \delta)$
% $$
% \begin{aligned}
% &k \rightleftarrows K \\
% &r \text { Ł } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
% &b \text { Ł }\{0,1\}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
% &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
% \end{aligned}
% $$
% $$
% \text { if } b=\hat{b}
% $$
% then output 1
% else output 0
% Game 2. [This is also a transition based on indistinguishability.] We now transform Game 1 into Game 2, computing $h$ by simply choosing it at random, rather than as a hash. Algorithmically, Game 2 looks like this:
% $x \leftrightarrows \mathbb{Z}_{q}, k \leftrightarrows K, \alpha \leftarrow \gamma^{x}$
% $r \stackrel{\star}{\leftarrow},\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
% $b$ Ł $\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z 亡 \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow\{0,1\}^{\ell}, v \leftarrow h \oplus m_{b}$
% $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$


% Game 0. This is the original attack game, which we can state algorithmically as follows:
% $$
% \begin{aligned}
% &x \leftarrow \mathbb{Z}_{q}, k \leftarrow K, \alpha \leftarrow \gamma^{x} \\
% &r \text { ๕ } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
% &b \Leftarrow\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, \delta \leftarrow \alpha^{y}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
% &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
% \end{aligned}
% $$
% We define $S_{0}$ to be the event that $b=\hat{b}$ in Game 0 .
% Game 1. [This is a transition based on indistinguishability.] Now we transform Game 0 into Game 1, computing $\delta$ as $\gamma^{z}$ for random $z \in \mathcal{Z}_{\text {q }}$. We can state Game 1 algorithmically as follows:
% $x \leftrightarrows \mathbb{Z}_{q}, k \hookleftarrow K, \alpha \leftarrow \gamma^{x}$
% $r \notin R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
% $b \leftrightarrows\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z \leftarrow \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b}$
% $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$
% Let $S_{1}$ be the event that $b=\hat{b}$ in Game 1 . We claim that
% $$
% \left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|=\epsilon_{\mathrm{ddh}}
% $$
% where $\epsilon_{\text {ddh }}$ is the DDH-advantage of some efficient algorithm (which is negligible under the DDH assumption).

% The proof of this is almost identical to the proof of the corresponding claim for "plain" ElGamal. Indeed, the following algorithm $D$ "interpolates" between Game 0 and Game 1 , and so has DDH-advantage equal to $\left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|$ :
% Algorithm $D(\alpha, \beta, \delta)$
% $$
% \begin{aligned}
% &k \rightleftarrows K \\
% &r \text { Ł } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
% &b \text { Ł }\{0,1\}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
% &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
% \end{aligned}
% $$
% $$
% \text { if } b=\hat{b}
% $$
% then output 1
% else output 0
% Game 2. [This is also a transition based on indistinguishability.] We now transform Game 1 into Game 2, computing $h$ by simply choosing it at random, rather than as a hash. Algorithmically, Game 2 looks like this:
% $x \leftrightarrows \mathbb{Z}_{q}, k \leftrightarrows K, \alpha \leftarrow \gamma^{x}$
% $r \stackrel{\star}{\leftarrow},\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
% $b$ Ł $\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z 亡 \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow\{0,1\}^{\ell}, v \leftarrow h \oplus m_{b}$
% $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$



% \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
% \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
% \newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
% \newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
% \newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

% \fancyhf{}
% \fancypagestyle{plain}{
% 	\renewcommand\headrulewidth{0.4pt}
% 	\renewcommand\footrulewidth{0.4pt}
% 	\setlength{\headheight}{30pt}
% 	\fancyhf{}
% 	\fancyhead[L]{Συναρτησιακή Κρυπτογραφία (Functional Encryption)}
% 	\fancyfoot[L]{ΘΕΟΔΩΡΟΣ ΣΥΜΕΩΝΙΔΗΣ Α.Μ:1064870}
% 	\fancyfoot[R]{\thepage}
% }

% \chapternumberfont{\large} 
% \chaptertitlefont{\fontfamily{qtm}\LARGE\selectfont}

% \lstset{
% 	showstringspaces=false,
% 	basicstyle=\linespread{0.4}\footnotesize,
% 	belowskip=1ex,
% 	breaklines=true,
% 	captionpos=b
% 	aboveskip= 0.1cm,
% 	belowskip=0.1cm
% }

% \fancypagestyle{plain}{
% 	\fancyfoot[R]{\thepage}}
% \printbibliography[title={\textgreek{\textbf{Βιβλιογραφία}}}]

% \usepackage[
% backend=biber,
% style=apa,
% citestyle=authoryear,
% language=english,
% autolang=other,natbib
% ]{biblatex}

% Για παράδειγμα, αν υποθέσουμε ότι το πλεονέκτημα του αντιπάλου στο Παιχνίδι $i$ είναι $\advantage{}{\adv}_i$ και στο Παιχνίδι $j$ είναι $\advantage{}{\adv}_j$ αντίστοιχα. Ακόμα έστω ότι τα δύο αυτά παιχνίδια διαφοροποιούνται σε


\begin{definition}
% \textbf{Συνάρτηση Κερκόπορτας (Trapdoor Function ή TDP)} : A trapdoor function is a collection of one-way functions { fk : Dk → Rk } (k ∈ K), in which all of K, Dk, Rk are subsets of binary strings {0, 1}*, satisfying the following conditions:

% There exists a probabilistic polynomial time (PPT) sampling algorithm Gen s.t. Gen(1n) = (k, tk) with k ∈ K ∩ {0, 1}n and tk ∈ {0, 1}* satisfies | tk | < p (n), in which p is some polynomial. Each tk is called the trapdoor corresponding to k. Each trapdoor can be efficiently sampled.
% Given input k, there also exists a PPT algorithm that outputs x ∈ Dk. That is, each Dk can be efficiently sampled.
% For any k ∈ K, there exists a PPT algorithm that correctly computes fk.
% For any k ∈ K, there exists a PPT algorithm A s.t. for any x ∈ Dk, let y = A ( k, fk(x), tk ), and then we have fk(y) = fk(x). That is, given trapdoor, it is easy to invert.
% For any k ∈ K, without trapdoor tk, for any PPT algorithm, the probability to correctly invert fk (i.e., given fk(x), find a pre-image x' such that fk(x' ) = fk(x)) is negligible.[3][4][5]
% If each function in the collection above is a one-way permutation, then the collection is also called a trapdoor permutation.
\end{definition}

% \begin{definition}
% \textbf{Κρυπτογραφικό Σχήμα RSA} : Ορίζεται ως ένα σύνολο αλγορίθμων $(Gen, Enc, Dec)$Έστω $N = p \cdot q$, όπου $p,q$ : πρώτοι
% \end{definition}