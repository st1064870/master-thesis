imslab@imslab-OptiPlex-5090:~$ openssl speed aes-256-cbc
Doing aes-256 cbc for 3s on 16 size blocks: 28706348 aes-256 cbc's in 3.00s
Doing aes-256 cbc for 3s on 64 size blocks: 7560946 aes-256 cbc's in 3.00s
Doing aes-256 cbc for 3s on 256 size blocks: 1906347 aes-256 cbc's in 3.00s
Doing aes-256 cbc for 3s on 1024 size blocks: 480042 aes-256 cbc's in 3.00s
Doing aes-256 cbc for 3s on 8192 size blocks: 59903 aes-256 cbc's in 3.00s
Doing aes-256 cbc for 3s on 16384 size blocks: 29956 aes-256 cbc's in 3.00s
OpenSSL 1.1.1f  31 Mar 2020
built on: Mon Jul  4 11:24:28 2022 UTC
options:bn(64,64) rc4(16x,int) des(int) aes(partial) blowfish(ptr) 
compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -Wa,--noexecstack -g -O2 -fdebug-prefix-map=/build/openssl-51ig8V/openssl-1.1.1f=. -fstack-protector-strong -Wformat -Werror=format-security -DOPENSSL_TLS_SECURITY_LEVEL=2 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DNDEBUG -Wdate-time -D_FORTIFY_SOURCE=2
The 'numbers' are in 1000s of bytes per second processed.
type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes  16384 bytes
aes-256 cbc     153100.52k   161300.18k   162674.94k   163854.34k   163575.13k   163599.70k
imslab@imslab-OptiPlex-5090:~$ openssl speed -seconds +3 rsa2048
Doing 2048 bits private rsa's for 3s: 4538 2048 bits private RSA's in 3.00s
Doing 2048 bits public rsa's for 3s: 158010 2048 bits public RSA's in 3.00s
OpenSSL 1.1.1f  31 Mar 2020
built on: Mon Jul  4 11:24:28 2022 UTC
options:bn(64,64) rc4(16x,int) des(int) aes(partial) blowfish(ptr) 
compiler: gcc -fPIC -pthread -m64 -Wa,--noexecstack -Wall -Wa,--noexecstack -g -O2 -fdebug-prefix-map=/build/openssl-51ig8V/openssl-1.1.1f=. -fstack-protector-strong -Wformat -Werror=format-security -DOPENSSL_TLS_SECURITY_LEVEL=2 -DOPENSSL_USE_NODELETE -DL_ENDIAN -DOPENSSL_PIC -DOPENSSL_CPUID_OBJ -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DKECCAK1600_ASM -DRC4_ASM -DMD5_ASM -DAESNI_ASM -DVPAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DX25519_ASM -DPOLY1305_ASM -DNDEBUG -Wdate-time -D_FORTIFY_SOURCE=2
                  sign    verify    sign/s verify/s
rsa 2048 bits 0.000661s 0.000019s   1512.7  52670.0
imslab@imslab-OptiPlex-5090:~$ 


\subsubsection{Χρήση ή υλοποίηση αποδοτικότερου αλγορίθμου Ανυποψίαστης Μεταφοράς}
Η βιβλιοθήκη ABY που χρησιμοποιήθηκε στην υλοποίηση χρησιμοποιεί την βιβλιοθήκη OTExtension \cite{OTExtensions}. Δυστυχώς για την συγκεκριμένη βιβλιοθήκη δεν παρέχεται κάποια ιδιαίτερη τεκμηρίωση ούτε εγχειρίδιο χρήσης. Ωστόσο, οι συγγραφείς της όπως ισχυρίζονται στην μικρή τεκμηρίωση που υπάρχει, η βιβλιοθήκη υλοποιεί διάφορα πρωτόκολλα Ανυποψίαστης Μεταφοράς αλλά και Επεκτάσεις τους μεταξύ τον οποίων και το πρωτόκολλο IKNP 1-2 που βασίζεται στην εργασία \cite{ishai2003extending}. Το πρωτόκολλο παρότι θεωρείται αρκετά αποδοτικό ως και σήμερα και χρησιμοποιείται ευρέως, έχουν προταθεί στην βιβλιογραφία πιο αποδοτικά προτόκολλα από αυτό. Μια βελτίωση που θα μπορούσε να υπάρξει στην πλευρά της υλοποίησης είναι να επεκτείνουμε την βιβλιοθήκη OTExtension ώστε να χρησιμοποιεί σύγχρονα πρωτόκολλα Ανυποψίαστης Μεταφοράς όπως \improvement{Add reasoning} ή να μετασχηματίσουμε την βιβλιοθήκη ABY ώστε να χρησιμοποιεί βιβλιοθήκες από την βιβλιογραφία που υλοποιούν σύγχρονα πρωτόκολλα Ανυποψίαστης Μεταφοράς όπως η \cite{libOTe}. H έμφαση που δώσαμε στα πρωτόκολλα ανυποψίαστης μεταφοράς δεν είναι τυχαία, είναι γνωστό ότι αποτελούν ένα από τα μεγαλύτερα σημεία συμφόρησης των σύγχρονων αλγορίθμων SMPC καθώς είναι ένα από τα  συστατικά στοιχεία που χρησιμοποιούνται ευρέως και σε μεγάλο βαθμό και κυρίως έχουν υψηλή πολυπλοκότητα επικοινωνίας και υπολογισμού \improvement{Add reasoning}.



\begin{definition}
    Ως Shannon Cipher ορίζεται το ζεύγος συναρτήσεων $\mathcal{E} = (E,D)$ οι οποίες όρίζονται ως εξής:
    \begin{itemize}
        \item $\mathcal{E} : \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{C}$
        \item $\mathcal{D} : \mathcal{K} \times \mathcal{C} \rightarrow \mathcal{M}$
    \end{itemize}
    όπου $\mathcal{M}$, $\mathcal{C}$, $\mathcal{D}$ είναι οι χώροι των μηνυμάτων, κρυπτοκειμένων και κλειδιών αντίστοιχα.
    \end{definition}
    
     σε ένα κβαντικό κανάλι επικοινωνίας μπορεί να γίνει αντιληπτή η παρουσία τρίτου σε αντίθεση με ένα ασύρματο κανάλι επικοινωνίας.
     
     όπως και με τους υπόλοιπους τελεστές. Ωστόσο, επειδή τον πολλαπλασιασμό των μετοχών το $[c]_i$ ανήκει πλέον σε ένα $SSS(n, 2t)$  ένας γύρος του πρωτοκόλου προκειμένου να μειωθεί το κατόφλι της διαμοίρασης από $2t$ σε $t$. 
     
     % Ας δούμε για παράδειγμα πως ορίζεται το παιχνίδι στην περίπτωση της Σημασιολογικής Ασφάλειας. \todo{}
    
    % \begin{figure}[H]
    % \centering
    % \fbox{
    %     \procedure{\ind-Game} {
    %     \textbf{Challenger \cdv} \< \< \textbf{Adversary \adv} \\
    %     \< \sendmessageleft*{m_0, m_1 \in M} \< \\
    %     b \sample \bin \< \< \\
    %     k \sample K \< \< \\
    %     c \sample E(k, m_b) \< \< \\
    %     \< \sendmessageright*{c} \< \\
    %     \< \sendmessageleft*{\hat{b} \in \{0, 1\}}\\
    %     }
    % }
    
    % \caption{Caption}
    % \label{fig:my_label}
    % \end{figure}
    
    % Game 0. This is the original attack game, which we can state algorithmically as follows:
    % $$
    % \begin{aligned}
    % &x \leftarrow \mathbb{Z}_{q}, k \leftarrow K, \alpha \leftarrow \gamma^{x} \\
    % &r \text { ๕ } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
    % &b \Leftarrow\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, \delta \leftarrow \alpha^{y}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
    % &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
    % \end{aligned}
    % $$
    % We define $S_{0}$ to be the event that $b=\hat{b}$ in Game 0 .
    % Game 1. [This is a transition based on indistinguishability.] Now we transform Game 0 into Game 1, computing $\delta$ as $\gamma^{z}$ for random $z \in \mathcal{Z}_{\text {q }}$. We can state Game 1 algorithmically as follows:
    % $x \leftrightarrows \mathbb{Z}_{q}, k \hookleftarrow K, \alpha \leftarrow \gamma^{x}$
    % $r \notin R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
    % $b \leftrightarrows\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z \leftarrow \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b}$
    % $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$
    % Let $S_{1}$ be the event that $b=\hat{b}$ in Game 1 . We claim that
    % $$
    % \left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|=\epsilon_{\mathrm{ddh}}
    % $$
    % where $\epsilon_{\text {ddh }}$ is the DDH-advantage of some efficient algorithm (which is negligible under the DDH assumption).
    
    % The proof of this is almost identical to the proof of the corresponding claim for "plain" ElGamal. Indeed, the following algorithm $D$ "interpolates" between Game 0 and Game 1 , and so has DDH-advantage equal to $\left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|$ :
    % Algorithm $D(\alpha, \beta, \delta)$
    % $$
    % \begin{aligned}
    % &k \rightleftarrows K \\
    % &r \text { Ł } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
    % &b \text { Ł }\{0,1\}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
    % &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
    % \end{aligned}
    % $$
    % $$
    % \text { if } b=\hat{b}
    % $$
    % then output 1
    % else output 0
    % Game 2. [This is also a transition based on indistinguishability.] We now transform Game 1 into Game 2, computing $h$ by simply choosing it at random, rather than as a hash. Algorithmically, Game 2 looks like this:
    % $x \leftrightarrows \mathbb{Z}_{q}, k \leftrightarrows K, \alpha \leftarrow \gamma^{x}$
    % $r \stackrel{\star}{\leftarrow},\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
    % $b$ Ł $\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z 亡 \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow\{0,1\}^{\ell}, v \leftarrow h \oplus m_{b}$
    % $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$
    
    
    % Game 0. This is the original attack game, which we can state algorithmically as follows:
    % $$
    % \begin{aligned}
    % &x \leftarrow \mathbb{Z}_{q}, k \leftarrow K, \alpha \leftarrow \gamma^{x} \\
    % &r \text { ๕ } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
    % &b \Leftarrow\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, \delta \leftarrow \alpha^{y}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
    % &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
    % \end{aligned}
    % $$
    % We define $S_{0}$ to be the event that $b=\hat{b}$ in Game 0 .
    % Game 1. [This is a transition based on indistinguishability.] Now we transform Game 0 into Game 1, computing $\delta$ as $\gamma^{z}$ for random $z \in \mathcal{Z}_{\text {q }}$. We can state Game 1 algorithmically as follows:
    % $x \leftrightarrows \mathbb{Z}_{q}, k \hookleftarrow K, \alpha \leftarrow \gamma^{x}$
    % $r \notin R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
    % $b \leftrightarrows\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z \leftarrow \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b}$
    % $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$
    % Let $S_{1}$ be the event that $b=\hat{b}$ in Game 1 . We claim that
    % $$
    % \left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|=\epsilon_{\mathrm{ddh}}
    % $$
    % where $\epsilon_{\text {ddh }}$ is the DDH-advantage of some efficient algorithm (which is negligible under the DDH assumption).
    
    % The proof of this is almost identical to the proof of the corresponding claim for "plain" ElGamal. Indeed, the following algorithm $D$ "interpolates" between Game 0 and Game 1 , and so has DDH-advantage equal to $\left|\operatorname{Pr}\left[S_{0}\right]-\operatorname{Pr}\left[S_{1}\right]\right|$ :
    % Algorithm $D(\alpha, \beta, \delta)$
    % $$
    % \begin{aligned}
    % &k \rightleftarrows K \\
    % &r \text { Ł } R,\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k) \\
    % &b \text { Ł }\{0,1\}, h \leftarrow H_{k}(\delta), v \leftarrow h \oplus m_{b} \\
    % &\hat{b} \leftarrow A(r, \alpha, k, \beta, v)
    % \end{aligned}
    % $$
    % $$
    % \text { if } b=\hat{b}
    % $$
    % then output 1
    % else output 0
    % Game 2. [This is also a transition based on indistinguishability.] We now transform Game 1 into Game 2, computing $h$ by simply choosing it at random, rather than as a hash. Algorithmically, Game 2 looks like this:
    % $x \leftrightarrows \mathbb{Z}_{q}, k \leftrightarrows K, \alpha \leftarrow \gamma^{x}$
    % $r \stackrel{\star}{\leftarrow},\left(m_{0}, m_{1}\right) \leftarrow A(r, \alpha, k)$
    % $b$ Ł $\{0,1\}, y \leftarrow \mathbb{Z}_{q}, \beta \leftarrow \gamma^{y}, z 亡 \mathbb{Z}_{q}, \delta \leftarrow \gamma^{z}, h \leftarrow\{0,1\}^{\ell}, v \leftarrow h \oplus m_{b}$
    % $\hat{b} \leftarrow A(r, \alpha, k, \beta, v)$
    
    
    
    % \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
    % \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
    % \newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
    % \newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
    % \newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}
    
    % \fancyhf{}
    % \fancypagestyle{plain}{
    % 	\renewcommand\headrulewidth{0.4pt}
    % 	\renewcommand\footrulewidth{0.4pt}
    % 	\setlength{\headheight}{30pt}
    % 	\fancyhf{}
    % 	\fancyhead[L]{Συναρτησιακή Κρυπτογραφία (Functional Encryption)}
    % 	\fancyfoot[L]{ΘΕΟΔΩΡΟΣ ΣΥΜΕΩΝΙΔΗΣ Α.Μ:1064870}
    % 	\fancyfoot[R]{\thepage}
    % }
    
    % \chapternumberfont{\large} 
    % \chaptertitlefont{\fontfamily{qtm}\LARGE\selectfont}
    
    % \lstset{
    % 	showstringspaces=false,
    % 	basicstyle=\linespread{0.4}\footnotesize,
    % 	belowskip=1ex,
    % 	breaklines=true,
    % 	captionpos=b
    % 	aboveskip= 0.1cm,
    % 	belowskip=0.1cm
    % }
    
    % \fancypagestyle{plain}{
    % 	\fancyfoot[R]{\thepage}}
    % \printbibliography[title={\textgreek{\textbf{Βιβλιογραφία}}}]
    
    % \usepackage[
    % backend=biber,
    % style=apa,
    % citestyle=authoryear,
    % language=english,
    % autolang=other,natbib
    % ]{biblatex}
    
    % Για παράδειγμα, αν υποθέσουμε ότι το πλεονέκτημα του αντιπάλου στο Παιχνίδι $i$ είναι $\advantage{}{\adv}_i$ και στο Παιχνίδι $j$ είναι $\advantage{}{\adv}_j$ αντίστοιχα. Ακόμα έστω ότι τα δύο αυτά παιχνίδια διαφοροποιούνται σε
    
    
    \begin{definition}
    % \textbf{Συνάρτηση Κερκόπορτας (Trapdoor Function ή TDP)} : A trapdoor function is a collection of one-way functions { fk : Dk → Rk } (k ∈ K), in which all of K, Dk, Rk are subsets of binary strings {0, 1}*, satisfying the following conditions:
    
    % There exists a probabilistic polynomial time (PPT) sampling algorithm Gen s.t. Gen(1n) = (k, tk) with k ∈ K ∩ {0, 1}n and tk ∈ {0, 1}* satisfies | tk | < p (n), in which p is some polynomial. Each tk is called the trapdoor corresponding to k. Each trapdoor can be efficiently sampled.
    % Given input k, there also exists a PPT algorithm that outputs x ∈ Dk. That is, each Dk can be efficiently sampled.
    % For any k ∈ K, there exists a PPT algorithm that correctly computes fk.
    % For any k ∈ K, there exists a PPT algorithm A s.t. for any x ∈ Dk, let y = A ( k, fk(x), tk ), and then we have fk(y) = fk(x). That is, given trapdoor, it is easy to invert.
    % For any k ∈ K, without trapdoor tk, for any PPT algorithm, the probability to correctly invert fk (i.e., given fk(x), find a pre-image x' such that fk(x' ) = fk(x)) is negligible.[3][4][5]
    % If each function in the collection above is a one-way permutation, then the collection is also called a trapdoor permutation.
    \end{definition}
    
    % \begin{definition}
    % \textbf{Κρυπτογραφικό Σχήμα RSA} : Ορίζεται ως ένα σύνολο αλγορίθμων $(Gen, Enc, Dec)$Έστω $N = p \cdot q$, όπου $p,q$ : πρώτοι
    % \end{definition}